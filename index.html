<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>dumpradio</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Live internet radio with audio-reactive 3D visuals">
    
    <!-- Open Graph / Discord -->
    <meta property="og:type" content="website">
    <meta property="og:title" content="dumpradio">
    <meta property="og:description" content="Live internet radio with audio-reactive 3D visuals">
    <meta property="og:image" content="https://radio.dmpstr.me/android-chrome-512x512.png">
    <meta property="og:url" content="https://radio.dmpstr.me/">
    <meta property="og:site_name" content="dumpradio">
    
    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="dumpradio">
    <meta name="twitter:description" content="Live internet radio with audio-reactive 3D visuals">
    <meta name="twitter:image" content="https://radio.dmpstr.me/android-chrome-512x512.png">
    
    <!-- Favicons -->
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
    <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
    <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="192x192" href="android-chrome-192x192.png">
    <link rel="icon" type="image/png" sizes="512x512" href="android-chrome-512x512.png">
    <link rel="manifest" href="site.webmanifest">
    
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#000000">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="dumpradio">
    
    <style>
        html, body {
            height: 100%;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: #000000;
            /* Solid black background - stays unfiltered */
            font-family: 'Inter', sans-serif;
            /* Post FX applied on #app-root for better mobile compatibility */
        }
        
        /* Pure black background layer that doesn't receive filters */
        body::before {
            content: '';
            position: fixed;
            inset: 0;
            background: #000000;
            z-index: -2;
        }


        canvas {
            display: block;
        }

        /* Background particles removed */

        /* App root that receives post-processing filter on all content */
        #app-root {
            position: fixed;
            inset: 0;
        }
        
        /* Universal post-processing using CSS filters (enable only when .postfx-on) */
        #scene-root, #ui-layer, #page-title {
            transition: filter 0.3s ease-out, -webkit-filter 0.3s ease-out;
        }
        
        #app-root.postfx-on #scene-root,
        #app-root.postfx-on #ui-layer,
        #app-root.postfx-on #page-title {
            filter: saturate(3) contrast(2) brightness(1) invert(1);
            -webkit-filter: saturate(2) contrast(2) brightness(2) ;
        }
        
        /* Color screen overlay - vibrant neon (multiply layer to darken inverted background) */
        /* Color controlled by CSS variables for easy switching */
        #app-root::after {
            content: '';
            position: fixed;
            inset: 0;
            background: radial-gradient(ellipse at center, 
                rgba(var(--filter-color-rgb, 255, 0, 0), 0.95) 0%, 
                rgb(var(--filter-color-rgb, 255, 0, 0)) 50%,
                rgb(var(--filter-color-rgb, 255, 0, 0)) 100%);
            mix-blend-mode:darken;
            pointer-events: none;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.3s ease-out, background 0.4s ease;
            /* Music reactive intensity - controlled by JS via CSS variable */
            filter: brightness(var(--red-brightness, 1));
            -webkit-filter: brightness(var(--red-brightness, 1));
        }
        
        #app-root.postfx-on::after {
            opacity: 1;
        }
        
        /* Additional glow layer for neon effect */
        #app-root::before {
            content: '';
            position: fixed;
            inset: 0;
            background: radial-gradient(ellipse at center, 
                transparent 0%, 
                rgb(0, 0, 0) 100%,
                transparent 100%);
            mix-blend-mode: screen;
            pointer-events: none;
            z-index: 99;
            filter: blur(40px);
            -webkit-filter: blur(40px);
            opacity: 0;
            transition: opacity 0.3s ease-out;
            /* Music reactive glow - controlled by JS via CSS variable */
            transform: scale(var(--glow-scale, 1));
        }
        
        #app-root.postfx-on::before {
            opacity: 1;
        }

        /* Hosting container for the WebGL canvas to make mobile layering explicit */
        #scene-root {
            position: absolute;
            inset: 0;
            z-index: 0;
            /* Transparent background so body black shows through unfiltered */
            background: transparent;
        }
        
        /* Make the WebGL canvas transparent so black background shows through */
        #scene-root canvas {
            background: transparent !important;
        }

        /* Ensure canvas always scales to viewport on mobile */
        #scene-root canvas {
            width: 100% !important;
            height: 100% !important;
            display: block;
        }

        /* Ensure background stays pure black - override any inherited filters */
        body, body::before {
            filter: none !important;
            -webkit-filter: none !important;
        }



        /* Page title */
        #page-title {
            position: fixed;
            top: 2vh;
            left: 50%;
            transform: translateX(-50%);
            font-size: clamp(48px, 12vw, 120px);
            font-weight: 900;
            letter-spacing: 0.3em;
            color: #ffffff;
            text-transform: lowercase;
            pointer-events: none;
            z-index: 15;
            user-select: none;
            /* Title should also be filtered for consistency */
            filter: saturate(16) contrast(1) brightness(1) invert(1);
            -webkit-filter: saturate(1) contrast(1) brightness(1) invert(1);
        }
        
        /* Mobile-specific title scaling */
        body.mobile #page-title {
            font-size: clamp(32px, 8vw, 70px);
            letter-spacing: 0.2em;
            white-space: nowrap;
        }
        
        #page-title span {
            display: inline-block;
            animation: titleJitter 4s linear infinite;
            font-family:monospace;
            font-size:20px;
        }
        
        /* Mobile-specific title character size */
        body.mobile #page-title span {
            font-size: 14px;
        }
        
        @keyframes titleJitter {
            0%, 100% {
                transform: translate(var(--jx, 0), var(--jy, 0)) rotate(var(--jr, 0));
            }
            50% {
                transform: translate(calc(var(--jx, 0) * -0.5), calc(var(--jy, 0) * -0.5)) rotate(calc(var(--jr, 0) * -0.5));
            }
        }
        
        /* Autoplay prompt overlay */
        #autoplay-prompt {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        
        #autoplay-prompt.show {
            opacity: 1;
            pointer-events: auto;
        }
        
        #autoplay-prompt .prompt-content {
            background: #1a1a1a;
            border: 3px solid #ffffff;
            padding: 40px 50px;
            text-align: center;
            max-width: 500px;
            color: #ffffff;
            font-family: monospace;
            box-shadow: 0 0 40px rgba(255, 255, 255, 0.2);
        }
        
        #autoplay-prompt h2 {
            margin: 0 0 20px 0;
            font-size: 24px;
            letter-spacing: 2px;
            text-transform: uppercase;
        }
        
        #autoplay-prompt p {
            margin: 0 0 30px 0;
            font-size: 14px;
            line-height: 1.6;
            opacity: 0.8;
        }
        
        #autoplay-prompt button {
            background: #ffffff;
            color: #000000;
            border: none;
            padding: 15px 40px;
            font-size: 16px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            cursor: pointer;
            font-family: monospace;
            transition: all 0.2s ease;
        }
        
        #autoplay-prompt button:hover {
            background: #ff5f02;
            color: #ffffff;
            transform: scale(1.05);
        }

        /* Persona/Katamari inspired UI layer */
        #ui-layer {
            position: fixed;
            inset: 0;
            pointer-events: none; /* let canvas keep receiving drags */
            z-index: 10; /* stay above the canvas */
        }

        #ui-layer.show .speech-bubble {
            opacity: 1;
            transform: translate(-50%, -50%) rotate(var(--rot, 0deg)) scale(1);
        }

        .speech-bubble {
            position: absolute;
            width: clamp(175px, 26vw, 240px);
            min-height: 64px;
            color: #000000;
            font-weight: 1000;
            letter-spacing: 0.8px;
            text-transform: uppercase;
            background: #fff8ea;
            --accent: #ff5724d8; /* Persona/Katamari orange-red */
            /* jaggy comic panel */
            --path: polygon(6% 0, 18% 6%, 34% 2%, 56% 8%, 74% 2%, 90% 9%, 100% 6%,
                           96% 26%, 100% 46%, 96% 70%, 100% 96%, 74% 100%, 52% 96%,
                           30% 100%, 8% 96%, 4% 72%, 0 52%, 5% 28%);
            clip-path: var(--path);
            padding: 2cqb 20px;
            border: none; /* border is drawn by ::before */
            outline: none;
            box-shadow: 0 10px 0 rgba(255, 72, 72, 0.25);
            transform: translate(-50%, -50%) rotate(var(--rot, 0deg)) scale(0.96);
            opacity: 0;
            transition: opacity 160ms ease, transform 200ms cubic-bezier(.2,.9,.2,1), 
                        background 150ms ease, color 150ms ease, width 200ms ease, box-shadow 200ms ease;
            pointer-events: auto; /* clickable buttons */
            cursor: pointer;
            user-select: none;
            animation: floaty 3.2s ease-in-out infinite, warble 4s ease-in-out infinite;
            z-index: 1; /* create a local stacking context for ::before/::after */
        }

        .speech-bubble::before { /* thick black border following the jaggy shape */
            content: "";
            position: absolute;
            inset: -6px;
            background: #ff5f02;
            clip-path: var(--path);
            z-index: -1;
            transition: background 150ms ease;
        }

        /* Hard dropshadow in accent color (no blur) */
        .speech-bubble::after {
            content: "";
            position: absolute;
            inset: 0px; /* expanded from default for bigger silhouette */
            background: var(--accent);
            clip-path: var(--path);
            transform: translate(2px, 0px) scale(0.9); /* larger hard offset + size */
            z-index: -1; /* behind bubble but above canvas */
            transition: background 150ms ease;
        }

        .speech-bubble:hover {
            transform: translate(-50%, -50%) rotate(var(--rot, 0deg)) scale(1.08) translateY(-2px);
            box-shadow: 0 15px 35px rgba(255, 72, 72, 0.4);
            background: #00ff00;
            color: #000000;
            animation-play-state: paused;
            width: clamp(145px, 38vw, 240px);
        }

        .speech-bubble:hover::before {
            background: #000000;
        }

        .speech-bubble:hover::after {
            background: #000000;
        }

        .speech-bubble:active {
            transform: translate(-50%, -50%) rotate(var(--rot, 0deg)) scale(2.98) translateY(1px);
            transition: all 0.1s ease;
        }

        /* Jittered per-letter text */
        .speech-bubble .letters span {
            display: inline-block;
            will-change: transform;
            animation: jitter 2s linear infinite;
            font-size: 1.8em;
        }

        /* Icon transitions */
        .speech-bubble .icon svg,
        .speech-bubble .volume-ui svg {
            transition: fill 150ms ease;
        }
        
        /* Mobile-specific bubble content scaling */
        body.mobile .speech-bubble .icon svg {
            width: 24px;
            height: 24px;
        }
        
        body.mobile .speech-bubble .volume-ui svg {
            width: 20px;
            height: 20px;
            margin-right: 6px !important;
        }
        
        body.mobile #volume-slider {
            width: 80px;
        }

        .speech-bubble:hover .icon svg,
        .speech-bubble:hover .volume-ui svg {
            fill: #ffffff;
        }

        /* Volume control layout inside bubble */
        .volume-ui {
            display: inline-flex;
            align-items: center;
        }
        #volume-slider {
            width: 120px;
            accent-color: #00ff00;
            transition: opacity 150ms ease, accent-color 150ms ease;
        }
        
        .speech-bubble:hover #volume-slider {
            accent-color: #000000;
        }

        @keyframes jitter {
            0%, 100% { transform: translate(0, 0) rotate(0deg); }
            30% { transform: translate(var(--jx, 1px), var(--jy, -1px)) rotate(var(--jr, 1deg)); }
            60% { transform: translate(calc(var(--jx, 1px) * -1), calc(var(--jy, 1px) * -1)) rotate(calc(var(--jr, 1deg) * -1)); }
        }

        @keyframes warble {
            0%, 100% { transform: translate(-50%, -50%) rotate(var(--rot, 0deg)) scale(0.96) rotate(0deg); }
            25% { transform: translate(-50%, -50%) rotate(var(--rot, 0deg)) scale(0.98) rotate(0.5deg); }
            50% { transform: translate(-50%, -50%) rotate(var(--rot, 0deg)) scale(0.96) rotate(0deg); }
            75% { transform: translate(-50%, -50%) rotate(var(--rot, 0deg)) scale(0.98) rotate(-0.5deg); }
        }

        /* Bubble tails (diamond rotated 45deg) with black border */
        .speech-bubble .tail {
            position: absolute;
            transform: rotate(45deg);
            background: #fff8ea;
        }
        .speech-bubble .tail::before {
            content: "";
            position: absolute;
            inset: 0px;
            background: #ffffff;
            z-index: -1;
        }

        /* Tail hard dropshadow matching accent */
        .speech-bubble .tail::after {
            content: "";
            position: absolute;
            inset: -10px;
            background: var(--accent);
            transform: translate(36px, 36px) scale(1.12);
            z-index: -1;
        }

        /* Quadrant-specific tilt and tail positions */
        .speech-bubble.top-left { --rot: -6deg; }
        .speech-bubble.top-right { --rot: 5deg; }
        .speech-bubble.bottom-left { --rot: 4deg; }
        .speech-bubble.bottom-right { --rot: -4deg; }

        .speech-bubble.top-left .tail { right: -10px; bottom: -10px; }
        .speech-bubble.top-right .tail { left: -10px; bottom: -10px; }
        .speech-bubble.bottom-left .tail { right: -10px; top: -10px; }
        .speech-bubble.bottom-right .tail { left: -10px; top: -10px; }

        @keyframes floaty {
            0%, 100% { translate: 0 0; }
            50% { translate: 0 -8px; }
        }
        
        /* Color cycle controls - bottom right anchored */
        #color-controls {
            position: fixed;
            bottom: clamp(20px, 3vh, 40px);
            right: clamp(20px, 3vw, 40px);
            display: flex;
            gap: 12px;
            z-index: 200;
            pointer-events: auto;
        }
        
        .color-arrow-btn {
            width: 50px;
            height: 50px;
            background: #fff8ea;
            border: 4px solid #000000;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            box-shadow: 4px 4px 0 rgba(0, 0, 0, 0.3);
            position: relative;
        }
        
        .color-arrow-btn:hover {
            background: #00ff00;
            transform: translateY(-2px);
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.4);
        }
        
        .color-arrow-btn:active {
            transform: translateY(1px);
            box-shadow: 2px 2px 0 rgba(0, 0, 0, 0.3);
        }
        
        .color-arrow-btn svg {
            width: 24px;
            height: 24px;
            fill: #000000;
            transition: fill 0.2s ease;
        }
        
        .color-arrow-btn:hover svg {
            fill: #ffffff;
        }
        
        /* Responsive scaling for smaller screens */
        @media (max-width: 640px) {
            .color-arrow-btn {
                width: 44px;
                height: 44px;
            }
            .color-arrow-btn svg {
                width: 20px;
                height: 20px;
            }
        }
    </style>

</head>

<body>

    <!-- Global SVG filter: maps luminance to red/black and adds neon glow -->
    <svg width="0" height="0" style="position:fixed; inset:0; pointer-events:none; opacity:0; z-index:-1">
        <defs>
        <filter id="redMapGlow" x="-50%" y="-50%" width="200%" height="200%" color-interpolation-filters="sRGB">
            <!-- Convert to luminance -->
            <feColorMatrix type="matrix" values="
                0.299 0.587 0.114 0 0
                0.299 0.587 0.114 0 0
                0.299 0.587 0.114 0 0
                0     0     0     1 0" result="lum"/>

            <!-- Increase contrast before mapping -->
            <feComponentTransfer in="lum" result="contrast">
                <feFuncR type="linear" slope="2.2" intercept="-0.6"/>
                <feFuncG type="linear" slope="2.2" intercept="-0.6"/>
                <feFuncB type="linear" slope="2.2" intercept="-0.6"/>
            </feComponentTransfer>

            <!-- Map luminance to red/black gradient -->
            <feComponentTransfer in="contrast" result="redmap">
                <feFuncR type="gamma" amplitude="1.5" exponent="0.8" offset="0"/>
                <feFuncG type="discrete" tableValues="0 0"/>
                <feFuncB type="discrete" tableValues="0 0"/>
            </feComponentTransfer>

            <!-- Create glow effect -->
            <feGaussianBlur in="redmap" stdDeviation="3" result="blur1"/>
            <feGaussianBlur in="redmap" stdDeviation="8" result="blur2"/>
            
            <!-- Merge glows and sharp image -->
            <feMerge result="glow">
                <feMergeNode in="blur2"/>
                <feMergeNode in="blur1"/>
                <feMergeNode in="redmap"/>
            </feMerge>

            <!-- Final intensity boost -->
            <feColorMatrix in="glow" type="matrix" values="
                2.0 0   0   0 0
                0   0   0   0 0
                0   0   0   0 0
                0   0   0   1 0"/>
        </filter>
        </defs>
    </svg>



    <!-- Background particles removed -->
    
    <!-- Autoplay prompt overlay -->
    <div id="autoplay-prompt">
        <div class="prompt-content">
            <h2>🎵 Audio Experience</h2>
            <p>This site features ambient music and audio elements.<br>Click below to enable sound and begin your journey.</p>
            <button id="enable-audio">Enable Audio</button>
        </div>
    </div>

    <!-- Wrap all on-screen content for unified mobile-friendly post FX -->
    <div id="app-root">
        <!-- Page title -->
        <div id="page-title">
            <span>d</span><span>u</span><span>m</span><span>p</span><span>r</span><span>a</span><span>d</span><span>i</span><span>o</span>
        </div>

        <!-- Scene root ensures canvas stacking is explicit on mobile -->
        <div id="scene-root"></div>

        <!-- Persona/Katamari inspired UI container -->
        <div id="ui-layer" aria-hidden="true">
            <!-- Top Left: Pause -->
            <button id="btn-pause" class="speech-bubble top-left" data-quadrant="tl" aria-label="Pause stream" title="Pause">
                <span class="icon" aria-hidden="true">
                    <svg width="36" height="36" viewBox="0 0 24 24" fill="#000" xmlns="http://www.w3.org/2000/svg">
                        <rect x="6" y="5" width="4" height="14" rx="1"/>
                        <rect x="14" y="5" width="4" height="14" rx="1"/>
                    </svg>
                </span>
                <span class="tail"></span>
            </button>

            <!-- Top Right: Play -->
            <button id="btn-play" class="speech-bubble top-right" data-quadrant="tr" aria-label="Play stream" title="Play">
                <span class="icon" aria-hidden="true">
                    <svg width="36" height="36" viewBox="0 0 24 24" fill="#000" xmlns="http://www.w3.org/2000/svg">
                        <path d="M8 5v14l11-7-11-7z"/>
                    </svg>
                </span>
                <span class="tail"></span>
            </button>

            <!-- Bottom Left: Volume -->
            <button id="btn-volume" class="speech-bubble bottom-left" data-quadrant="bl" aria-label="Volume" title="Volume">
                <div class="volume-ui" aria-hidden="true">
                    <svg width="28" height="28" viewBox="0 0 24 24" fill="#000" xmlns="http://www.w3.org/2000/svg" style="margin-right:8px">
                        <path d="M3 10v4h4l5 5V5L7 10H3z"/>
                    </svg>
                    <input id="volume-slider" type="range" min="0" max="100" step="1" value="35" aria-label="Volume slider" />
                </div>
                <span class="tail"></span>
            </button>

            <!-- Bottom Right: Discord link -->
            <button id="btn-discord" class="speech-bubble bottom-right" data-quadrant="br" aria-label="Discord" title="Discord">
                <span class="icon" aria-hidden="true">
                    <svg xmlns="http://www.w3.org/2000/svg" width="36" height="36" fill="currentColor" viewBox="0 0 16 16">
                        <path d="M13.545 2.907a13.2 13.2 0 0 0-3.257-1.011.05.05 0 0 0-.052.025c-.141.25-.297.577-.406.833a12.2 12.2 0 0 0-3.658 0 8 8 0 0 0-.412-.833.05.05 0 0 0-.052-.025c-1.125.194-2.22.534-3.257 1.011a.04.04 0 0 0-.021.018C.356 6.024-.213 9.047.066 12.032q.003.022.021.037a13.3 13.3 0 0 0 3.995 2.02.05.05 0 0 0 .056-.019q.463-.63.818-1.329a.05.05 0 0 0-.01-.059l-.018-.011a9 9 0 0 1-1.248-.595.05.05 0 0 1-.02-.066l.015-.019q.127-.095.248-.195a.05.05 0 0 1 .051-.007c2.619 1.196 5.454 1.196 8.041 0a.05.05 0 0 1 .053.007q.121.1.248.195a.05.05 0 0 1-.004.085 8 8 0 0 1-1.249.594.05.05 0 0 0-.03.03.05.05 0 0 0 .003.041c.24.465.515.909.817 1.329a.05.05 0 0 0 .056.019 13.2 13.2 0 0 0 4.001-2.02.05.05 0 0 0 .021-.037c.334-3.451-.559-6.449-2.366-9.106a.03.03 0 0 0-.02-.019m-8.198 7.307c-.789 0-1.438-.724-1.438-1.612s.637-1.613 1.438-1.613c.807 0 1.45.73 1.438 1.613 0 .888-.637 1.612-1.438 1.612m5.316 0c-.788 0-1.438-.724-1.438-1.612s.637-1.613 1.438-1.613c.807 0 1.451.73 1.438 1.613 0 .888-.631 1.612-1.438 1.612"/>
                    </svg>
                </span>
                <span class="tail"></span>
            </button>
        </div>
        
        <!-- Color cycle controls -->
        <div id="color-controls">
            <button id="btn-color-prev" class="color-arrow-btn" aria-label="Previous color" title="Previous color">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M15 18l-6-6 6-6"/>
                </svg>
            </button>
            <button id="btn-color-next" class="color-arrow-btn" aria-label="Next color" title="Next color">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M9 18l6-6-6-6"/>
                </svg>
            </button>
        </div>
    </div>

    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.skypack.dev/three@0.128.0/build/three.module.js",
          "three/addons/": "https://cdn.skypack.dev/three@0.128.0/examples/jsm/"
        }
      }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // ═══════════════════════════════════════════════════════════════
        // CONFIGURATION: Stream URL
        // ═══════════════════════════════════════════════════════════════
        // ✅ HTTPS stream URL - works with GitHub Pages!
        const STREAM_URL = 'https://stream.dmpstr.me/radio.mp3';
        // ═══════════════════════════════════════════════════════════════

        // Mobile detection
        function detectMobile() {
            const userAgent = navigator.userAgent || navigator.vendor || window.opera;
            const isMobileUA = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(userAgent.toLowerCase());
            const isMobileScreen = window.innerWidth <= 768 || window.innerHeight <= 768;
            const isIOS = /iPad|iPhone|iPod/.test(userAgent) && !window.MSStream;
            const isSafari = /^((?!chrome|android).)*safari/i.test(userAgent);
            
            return {
                isMobile: isMobileUA || isMobileScreen,
                isIOS: isIOS,
                isSafari: isSafari,
                isIOSSafari: isIOS && isSafari
            };
        }
        
        const deviceInfo = detectMobile();
        
        // Apply mobile class to body
        if (deviceInfo.isMobile) {
            document.body.classList.add('mobile');
            // console.log('Mobile device detected:', deviceInfo);
        }
        
        // Recheck on resize
        window.addEventListener('resize', () => {
            const newCheck = detectMobile();
            if (newCheck.isMobile && !document.body.classList.contains('mobile')) {
                document.body.classList.add('mobile');
            } else if (!newCheck.isMobile && document.body.classList.contains('mobile')) {
                document.body.classList.remove('mobile');
            }
        });
        
        // Check for mixed content issues (HTTPS page loading HTTP audio)
        function checkMixedContent(streamUrl) {
            const pageProtocol = window.location.protocol;
            const streamProtocol = streamUrl.startsWith('http://') ? 'http:' : 
                                  streamUrl.startsWith('https://') ? 'https:' : 
                                  'unknown';
            
            if (pageProtocol === 'https:' && streamProtocol === 'http:') {
                console.error('⚠️ MIXED CONTENT ERROR DETECTED! ⚠️');
                console.error('Page is HTTPS but stream is HTTP - browser will block this!');
                console.error('Page:', window.location.href);
                console.error('Stream:', streamUrl);
                console.error('SOLUTION: Use HTTPS stream URL or serve page over HTTP');
                return true;
            }
            return false;
        }

        // Background particles removed

        // Simple Simplex/Perlin Noise Implementation
        var NOISE = NOISE || { };
        NOISE.Perlin = (function() {
            var iOctaves = 1,
                fPersistence = 0.2,
                fResult, fFreq, fPers,
                aOctFreq, // frequency per octave
                aOctPers, // persistance per octave
                fPersMax; // 1 / max persistence

            var octaveFreq = function() {
                var fFreq, fPers;
                aOctFreq = new Array();
                aOctPers = new Array();
                fPersMax = 0;
                for (var i=0; i < iOctaves; i++) {
                    fFreq = Math.pow(2,i);
                    fPers = Math.pow(fPersistence, i);
                    fPersMax += fPers;
                    aOctFreq.push(fFreq);
                    aOctPers.push(fPers);
                }
                fPersMax = 2 / fPersMax;
            }

            var perm = new Uint8Array(512);
            var p = new Uint8Array(256);
            var grad3 = [[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],
                         [1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],
                         [0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]];

            // Return the dot product for 2d perlin noise
            function dot2(g, x, y) {
                return g[0]*x + g[1]*y;
            }

            // Return the dot product for 3d perlin noise
            function dot3(g, x, y, z) {
                return g[0]*x + g[1]*y + g[2]*z;
            }

            // Seeded random number generator
            function seed(x) {
                x = (x<<13) ^ x;
                return ( 1.0 - ( (x * (x * x * 15731 + 789221) + 1376312589) & 0x7fffffff) / 1073741824.0);
            }

            function init() {
                for (var i = 0; i < 256; i++) {
                    p[i] = Math.abs(~~(seed(i) * 256));
                }
                // To remove the need for index wrapping, double the permutation table length
                for (var i=0; i < 512; i++) {
                    perm[i] = p[i & 255];
                }
            }

            /*
            ** 2D Simplex Noise
            */
            function noise2D (x, y, z) {
                // Find unit grid cell containing point
                var X = Math.floor(x) & 255;
                var Y = Math.floor(y) & 255;
                // Get relative xyz coordinates of point within that cell
                x -= Math.floor(x);
                y -= Math.floor(y);

                var fade = function(t) {
                    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
                };

                var lerp = function(a, b, t) {
                    return (1.0-t)*a + t*b;
                }

                var u = fade(x),
                    v = fade(y);

                // Calculate a set of four hashed gradient indices
                var n00 = perm[X + perm[Y ]] % 12;
                var n01 = perm[X + perm[Y+1]] % 12;
                var n10 = perm[X+1 + perm[Y+1]] % 12;
                var n11 = perm[X+1 + perm[Y+1]] % 12;

                // Calculate noise contributions from each of the four corners
                var gi00 = dot2(grad3[n00], x, y );
                var gi01 = dot2(grad3[n01], x, y-1);
                var gi10 = dot2(grad3[n10], x-1, y );
                var gi11 = dot2(grad3[n11], x-1, y-1);

                // Interpolate the results along axises
                return lerp(
                    lerp(gi00, gi10, u),
                    lerp(gi01, gi11, u),
                    v);
            }

            /*
            ** 3D Simplex Noise
            */
            function noise3D (x, y, z) {
                // Find unit grid cell containing point
                var X = Math.floor(x) & 255;
                var Y = Math.floor(y) & 255;
                var Z = Math.floor(z) & 255;
                // Get relative xyz coordinates of point within that cell
                x -= Math.floor(x);
                y -= Math.floor(y);
                z -= Math.floor(z);

                var fade = function(t) {
                    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
                };

                var lerp = function(a, b, t) {
                    return (1.0-t)*a + t*b;
                }

                var u = fade(x),
                    v = fade(y),
                    w = fade(z);

                // Calculate a set of eight hashed gradient indices
                var n000 = perm[X + perm[Y + perm[Z ]]] % 12;
                var n001 = perm[X + perm[Y + perm[Z+1]]] % 12;
                var n010 = perm[X + perm[Y+1+perm[Z ]]] % 12;
                var n011 = perm[X + perm[Y+1+perm[Z+1]]] % 12;
                var n100 = perm[X+1+perm[Y + perm[Z ]]] % 12;
                var n101 = perm[X+1+perm[Y + perm[Z+1]]] % 12;
                var n110 = perm[X+1+perm[Y+1+perm[Z ]]] % 12;
                var n111 = perm[X+1+perm[Y+1+perm[Z+1]]] % 12;

                // Calculate noise contributions from each of the eight corners
                var gi000 = dot3(grad3[n000], x, y, z );
                var gi001 = dot3(grad3[n001], x, y, z-1);
                var gi010 = dot3(grad3[n010], x, y-1, z );
                var gi011 = dot3(grad3[n011], x, y-1, z-1);
                var gi100 = dot3(grad3[n100], x-1, y, z );
                var gi101 = dot3(grad3[n101], x-1, y, z-1);
                var gi110 = dot3(grad3[n110], x-1, y-1, z );
                var gi111 = dot3(grad3[n111], x-1, y-1, z-1);

                // Interpolate the results along axises
                return lerp(
                    lerp(
                        lerp(gi000, gi100, u),
                        lerp(gi001, gi101, u), w),
                    lerp(
                        lerp(gi010, gi110, u),
                        lerp(gi011, gi111, u), w),
                    v);
            }

            function PerlinNoise(){}
            PerlinNoise.prototype = {
                init : init,
                noise : function(x, y, z) {
                    fResult = 0;
                    for (var i=0; i < iOctaves; i++) {
                        fFreq = aOctFreq[i];
                        fPers = aOctPers[i];
                        switch(arguments.length) {
                            case 3 : fResult += fPers * noise3D(fFreq*x, fFreq*y, fFreq*z);
                                     break;
                            case 2 : fResult += fPers * noise2D(fFreq*x, fFreq*y);
                                     break;
                            default : fResult += fPers * noise3D(fFreq*x, fFreq*y, fFreq*z);
                                      break;
                        }
                    }
                    return (fResult * fPersMax + 0.8) * 0.5
                },
                noiseDetail : function(octaves, persistance) {
                    iOctaves = octaves || iOctaves;
                    fPersistence = persistance || fPersistence;
                    octaveFreq();
                }
            }

            return PerlinNoise;
        }).call(this);

        let scene, camera, renderer, controls;
        let planetGroup, moonOrbit;
        let perlin;
        let mouse, raycaster;
        let wasHovered = false;
        let planetMesh, outlineMesh, moonOutlineRef;
        let satelliteOrbit, satelliteGroup, satelliteRoot, satelliteOutlineRef;
        let animating = false;
        let animationStartTime;
        const animationDuration = 0.5; // seconds for one bounce
        let hoverEnabled = false;

        // Audio references at module scope for accessibility
        let audioLoop, audioStatic, audioStream;
        const radioScale = 0.75; // cap radio at 75% volume
        
        // Audio visualization setup
        let audioContext, analyser, dataArray, bufferLength;
        let loopSource, streamSource;
        let currentAudioSource = null;
        
        // Music reactive elements
        let appRootElement, redOverlay, glowOverlay;
        
        // Visualization system
        let visualizations = [];
        let currentVisualizationIndex = 0;
        let visualizationTransitionTimer = 0;
        let visualizationDuration = 20; // seconds per visualization (base duration)
        let isTransitioning = false;
        
        // Randomize duration for each visualization to keep it unpredictable
        function getRandomVisualizationDuration() {
            return 15 + Math.random() * 15; // Random duration between 15-30 seconds
        }

        function onMouseMove(event) {
            hoverEnabled = true;
            mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
            mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
        }
        
        // Initialize audio visualization with gain control for smooth switching
        let masterGain;
        
        function setupAudioVisualization(audioElement, label = 'audio') {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256; // Good balance of performance and detail
                
                // IMPORTANT: Set analyser to be completely transparent (no audio coloration)
                analyser.smoothingTimeConstant = 0.3; // Reduced from default 0.8 for more responsive analysis
                analyser.minDecibels = -90; // Default, but explicitly set for clarity
                analyser.maxDecibels = -10; // Default, but explicitly set for clarity
                
                bufferLength = analyser.frequencyBinCount;
                dataArray = new Uint8Array(bufferLength);
                
                // Create master gain node
                masterGain = audioContext.createGain();
                masterGain.gain.value = 1.0; // Unity gain - no amplification or attenuation
                
                // Route: analyser -> masterGain -> destination
                // Note: Analyser is a "transparent" node and doesn't affect audio quality
                analyser.connect(masterGain);
                masterGain.connect(audioContext.destination);
            }
            
            try {
                // Create source from audio element (can only be done once per element)
                const source = audioContext.createMediaElementSource(audioElement);
                
                // Connect source -> analyser
                source.connect(analyser);
                
                // console.log(`Audio visualization connected for ${label}`);
                return source;
            } catch (err) {
                console.warn(`Could not setup visualization for ${label}:`, err);
                return null;
            }
        }
        
        // Get current audio level (0-1)
        let lastAudioLevel = 0;
        let audioDebugCounter = 0;
        function getAudioLevel() {
            if (!analyser || !dataArray) return 0;
            
            // Resume audio context if it got suspended somehow
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }
            
            analyser.getByteFrequencyData(dataArray);
            
            // Calculate average volume across frequency spectrum
            let sum = 0;
            for (let i = 0; i < bufferLength; i++) {
                sum += dataArray[i];
            }
            const average = sum / bufferLength;
            
            // Normalize to 0-1 range and apply some scaling for better reactivity
            const level = Math.min(1, (average / 255) * 2.5);
            
            // Debug logging disabled to prevent console spam
            // audioDebugCounter++;
            // if (audioDebugCounter >= 180) {
            //     const activeSource = !audioLoop?.paused ? 'loop' : !audioStream?.paused ? 'stream' : 'none';
            //     console.log('Audio level:', level.toFixed(3), 'Raw avg:', average.toFixed(1), 'Active:', activeSource, 'Context:', audioContext?.state);
            //     audioDebugCounter = 0;
            // }
            
            lastAudioLevel = level;
            return level;
        }
        
        // Get bass level specifically (lower frequencies)
        function getBassLevel() {
            if (!analyser || !dataArray) return 0;
            
            analyser.getByteFrequencyData(dataArray);
            
            // Focus on lower frequencies (bass range, roughly 0-250Hz)
            const bassRange = Math.floor(bufferLength * 0.2); // First 20% of spectrum
            let sum = 0;
            for (let i = 0; i < bassRange; i++) {
                sum += dataArray[i];
            }
            const average = sum / bassRange;
            
            // Normalize and boost bass reactivity
            return Math.min(1, (average / 255) * 3);
        }
        
        // Get frequency data as array (for spectrum visualizations)
        function getFrequencyData() {
            if (!analyser || !dataArray) return new Uint8Array(32);
            analyser.getByteFrequencyData(dataArray);
            return dataArray;
        }
        
        // Debug function to check audio setup
        function checkAudioSetup() {
            console.log('=== Audio Setup Check ===');
            console.log('AudioContext:', audioContext ? 'Created' : 'Missing');
            console.log('AudioContext state:', audioContext?.state);
            console.log('Analyser:', analyser ? 'Created' : 'Missing');
            console.log('Analyser fftSize:', analyser?.fftSize);
            console.log('Loop source:', loopSource ? 'Connected' : 'Not connected');
            console.log('Stream source:', streamSource ? 'Connected' : 'Not connected');
            console.log('AudioLoop paused:', audioLoop?.paused);
            console.log('AudioStream paused:', audioStream?.paused);
            console.log('AudioStream src:', audioStream?.src || 'Not set');
            console.log('========================');
        }
        
        // ========== VISUALIZATION CLASSES ==========
        
        // 1. Radial Spectrum Analyzer - bars radiating from edges
        class RadialSpectrum {
            constructor(scene) {
                this.group = new THREE.Group();
                this.bars = [];
                const barCount = 64;
                const radius = 8; // Far from center
                
                for (let i = 0; i < barCount; i++) {
                    const geometry = new THREE.BoxGeometry(0.08, 0.1, 0.08);
                    const material = new THREE.MeshBasicMaterial({ 
                        color: 0xffffff,
                        wireframe: true,
                        transparent: true,
                        opacity: 0
                    });
                    const bar = new THREE.Mesh(geometry, material);
                    
                    const angle = (i / barCount) * Math.PI * 2;
                    bar.position.x = Math.cos(angle) * radius;
                    bar.position.y = Math.sin(angle) * radius;
                    bar.position.z = -2;
                    bar.rotation.z = angle;
                    
                    this.bars.push(bar);
                    this.group.add(bar);
                }
                
                scene.add(this.group);
                this.group.visible = false;
            }
            
            update(audioLevel, bassLevel, frequencyData) {
                const stride = Math.floor(frequencyData.length / this.bars.length);
                this.bars.forEach((bar, i) => {
                    const freq = frequencyData[i * stride] / 255;
                    const targetScale = 0.5 + freq * 3;
                    bar.scale.y += (targetScale - bar.scale.y) * 0.15;
                    bar.material.opacity = 0.3 + freq * 0.5;
                });
            } 
            
            fadeIn(duration = 2) {
                this.group.visible = true;
                return new Promise(resolve => {
                    const start = performance.now();
                    const tick = () => {
                        const elapsed = (performance.now() - start) / 1000;
                        const progress = Math.min(1, elapsed / duration);
                        this.bars.forEach(bar => {
                            bar.material.opacity = progress * 0.6;
                        });
                        if (progress < 1) requestAnimationFrame(tick);
                        else resolve();
                    };
                    tick();
                });
            }
            
            fadeOut(duration = 2) {
                return new Promise(resolve => {
                    const start = performance.now();
                    const tick = () => {
                        const elapsed = (performance.now() - start) / 1000;
                        const progress = Math.min(1, elapsed / duration);
                        this.bars.forEach(bar => {
                            bar.material.opacity = (1 - progress) * 0.6;
                        });
                        if (progress < 1) {
                            requestAnimationFrame(tick);
                        } else {
                            this.group.visible = false;
                            resolve();
                        }
                    };
                    tick();
                });
            }
        }
        
        // 2. Particle Field - reactive particles in background
        class ParticleField {
            constructor(scene) {
                const particleCount = 200;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const velocities = [];
                
                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3] = (Math.random() - 0.5) * 20;
                    positions[i * 3 + 1] = (Math.random() - 0.5) * 20;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 10 - 5;
                    
                    velocities.push(new THREE.Vector3(
                        (Math.random() - 0.5) * 0.02,
                        (Math.random() - 0.5) * 0.02,
                        (Math.random() - 0.5) * 0.01
                    ));
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                const material = new THREE.PointsMaterial({
                    color: 0xffffff,
                    size: 0.05,
                    transparent: true,
                    opacity: 0
                });
                
                this.particles = new THREE.Points(geometry, material);
                this.velocities = velocities;
                this.basePositions = positions.slice();
                scene.add(this.particles);
                this.particles.visible = false;
            }
            
            update(audioLevel, bassLevel) {
                const positions = this.particles.geometry.attributes.position.array;
                const pushForce = bassLevel * 0.3;
                
                for (let i = 0; i < positions.length / 3; i++) {
                    const idx = i * 3;
                    positions[idx] += this.velocities[i].x + pushForce * (Math.random() - 0.5);
                    positions[idx + 1] += this.velocities[i].y + pushForce * (Math.random() - 0.5);
                    positions[idx + 2] += this.velocities[i].z;
                    
                    // Wrap around
                    if (Math.abs(positions[idx]) > 10) positions[idx] *= -0.9;
                    if (Math.abs(positions[idx + 1]) > 10) positions[idx + 1] *= -0.9;
                    if (positions[idx + 2] < -8) positions[idx + 2] = 2;
                    if (positions[idx + 2] > 2) positions[idx + 2] = -8;
                }
                
                this.particles.geometry.attributes.position.needsUpdate = true;
                this.particles.material.size = 0.05 + audioLevel * 0.08;
            }
            
            fadeIn(duration = 2) {
                this.particles.visible = true;
                return new Promise(resolve => {
                    const start = performance.now();
                    const tick = () => {
                        const elapsed = (performance.now() - start) / 1000;
                        const progress = Math.min(1, elapsed / duration);
                        this.particles.material.opacity = progress * 0.4;
                        if (progress < 1) requestAnimationFrame(tick);
                        else resolve();
                    };
                    tick();
                });
            }
            
            fadeOut(duration = 2) {
                return new Promise(resolve => {
                    const start = performance.now();
                    const tick = () => {
                        const elapsed = (performance.now() - start) / 1000;
                        const progress = Math.min(1, elapsed / duration);
                        this.particles.material.opacity = (1 - progress) * 0.4;
                        if (progress < 1) {
                            requestAnimationFrame(tick);
                        } else {
                            this.particles.visible = false;
                            resolve();
                        }
                    };
                    tick();
                });
            }
        }
        
        // 3. Wireframe Torus - pulsing geometric shape
        class WireframeTorus {
            constructor(scene) {
                this.group = new THREE.Group();
                
                // Multiple nested tori for depth
                this.tori = [];
                for (let i = 0; i < 3; i++) {
                    const geometry = new THREE.TorusGeometry(5 + i * 0.5, 0.1, 8, 32);
                    const material = new THREE.MeshBasicMaterial({
                        color: 0xffffff,
                        wireframe: true,
                        transparent: true,
                        opacity: 0
                    });
                    const torus = new THREE.Mesh(geometry, material);
                    torus.rotation.x = Math.PI / 2;
                    torus.position.z = -5;
                    this.tori.push(torus);
                    this.group.add(torus);
                }
                
                scene.add(this.group);
                this.group.visible = false;
                this.rotationSpeed = 0.005;
            }
            
            update(audioLevel, bassLevel) {
                this.tori.forEach((torus, i) => {
                    torus.rotation.z += this.rotationSpeed * (1 + i * 0.2);
                    const scale = 1 + bassLevel * 0.15 + audioLevel * 0.1;
                    torus.scale.set(scale, scale, scale);
                    torus.material.opacity = 0.2 + audioLevel * 0.3;
                });
            }
            
            fadeIn(duration = 2) {
                this.group.visible = true;
                return new Promise(resolve => {
                    const start = performance.now();
                    const tick = () => {
                        const elapsed = (performance.now() - start) / 1000;
                        const progress = Math.min(1, elapsed / duration);
                        this.tori.forEach(torus => {
                            torus.material.opacity = progress * 0.3;
                        });
                        if (progress < 1) requestAnimationFrame(tick);
                        else resolve();
                    };
                    tick();
                });
            }
            
            fadeOut(duration = 2) {
                return new Promise(resolve => {
                    const start = performance.now();
                    const tick = () => {
                        const elapsed = (performance.now() - start) / 1000;
                        const progress = Math.min(1, elapsed / duration);
                        this.tori.forEach(torus => {
                            torus.material.opacity = (1 - progress) * 0.3;
                        });
                        if (progress < 1) {
                            requestAnimationFrame(tick);
                        } else {
                            this.group.visible = false;
                            resolve();
                        }
                    };
                    tick();
                });
            }
        }
        
        // 4. Waveform Ring - circular waveform display
        class WaveformRing {
            constructor(scene) {
                const segments = 128;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(segments * 3);
                const radius = 6;
                
                for (let i = 0; i < segments; i++) {
                    const angle = (i / segments) * Math.PI * 2;
                    positions[i * 3] = Math.cos(angle) * radius;
                    positions[i * 3 + 1] = Math.sin(angle) * radius;
                    positions[i * 3 + 2] = -3;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                const material = new THREE.LineBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0,
                    linewidth: 6
                });
                
                this.line = new THREE.Line(geometry, material);
                this.baseRadius = radius;
                scene.add(this.line);
                this.line.visible = false;
            }
            
            update(audioLevel, bassLevel, frequencyData) {
                const positions = this.line.geometry.attributes.position.array;
                const segments = positions.length / 3;
                const stride = Math.floor(frequencyData.length / segments);
                
                for (let i = 0; i < segments; i++) {
                    const angle = (i / segments) * Math.PI * 2;
                    const freq = frequencyData[i * stride] / 255;
                    const radius = this.baseRadius + freq * 2;
                    positions[i * 3] = Math.cos(angle) * radius;
                    positions[i * 3 + 1] = Math.sin(angle) * radius;
                }
                
                this.line.geometry.attributes.position.needsUpdate = true;
                this.line.rotation.z += 0.002;
            }
            
            fadeIn(duration = 2) {
                this.line.visible = true;
                return new Promise(resolve => {
                    const start = performance.now();
                    const tick = () => {
                        const elapsed = (performance.now() - start) / 1000;
                        const progress = Math.min(1, elapsed / duration);
                        this.line.material.opacity = progress * 0.5;
                        if (progress < 1) requestAnimationFrame(tick);
                        else resolve();
                    };
                    tick();
                });
            }
            
            fadeOut(duration = 2) {
                return new Promise(resolve => {
                    const start = performance.now();
                    const tick = () => {
                        const elapsed = (performance.now() - start) / 1000;
                        const progress = Math.min(1, elapsed / duration);
                        this.line.material.opacity = (1 - progress) * 0.5;
                        if (progress < 1) {
                            requestAnimationFrame(tick);
                        } else {
                            this.line.visible = false;
                            resolve();
                        }
                    };
                    tick();
                });
            }
        }
        
        // 5. Grid Distortion - deforming background grid
        class GridDistortion {
            constructor(scene) {
                const size = 20;
                const divisions = 40;
                
                // Create custom grid geometry for deformation
                const geometry = new THREE.BufferGeometry();
                const vertices = [];
                
                const step = size / divisions;
                for (let i = 0; i <= divisions; i++) {
                    // Horizontal lines
                    vertices.push(-size/2, i * step - size/2, -8);
                    vertices.push(size/2, i * step - size/2, -8);
                    // Vertical lines
                    vertices.push(i * step - size/2, -size/2, -8);
                    vertices.push(i * step - size/2, size/2, -8);
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(vertices), 3));
                
                const material = new THREE.LineBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0
                });
                
                this.grid = new THREE.LineSegments(geometry, material);
                this.basePositions = vertices.slice();
                this.divisions = divisions;
                scene.add(this.grid);
                this.grid.visible = false;
                this.time = 0;
            }
            
            update(audioLevel, bassLevel) {
                this.time += 0.02;
                const positions = this.grid.geometry.attributes.position.array;
                
                for (let i = 0; i < positions.length / 3; i++) {
                    const idx = i * 3;
                    const x = this.basePositions[idx];
                    const y = this.basePositions[idx + 1];
                    
                    // Wave distortion based on audio
                    const distortion = Math.sin(x * 0.3 + this.time) * Math.cos(y * 0.3 + this.time) * (bassLevel * 4 + audioLevel);
                    positions[idx + 2] = this.basePositions[idx + 2] + distortion;
                }
                
                this.grid.geometry.attributes.position.needsUpdate = true;
            }
            
            fadeIn(duration = 2) {
                this.grid.visible = true;
                return new Promise(resolve => {
                    const start = performance.now();
                    const tick = () => {
                        const elapsed = (performance.now() - start) / 1000;
                        const progress = Math.min(1, elapsed / duration);
                        this.grid.material.opacity = progress * 0.15;
                        if (progress < 1) requestAnimationFrame(tick);
                        else resolve();
                    };
                    tick();
                });
            }
            
            fadeOut(duration = 2) {
                return new Promise(resolve => {
                    const start = performance.now();
                    const tick = () => {
                        const elapsed = (performance.now() - start) / 1000;
                        const progress = Math.min(1, elapsed / duration);
                        this.grid.material.opacity = (1 - progress) * 0.15;
                        if (progress < 1) {
                            requestAnimationFrame(tick);
                        } else {
                            this.grid.visible = false;
                            resolve();
                        }
                    };
                    tick();
                });
            }
        }
        
        // 6. Orbital Rings - rotating rings at different angles
        class OrbitalRings {
            constructor(scene) {
                this.group = new THREE.Group();
                this.rings = [];
                
                for (let i = 0; i < 4; i++) {
                    const geometry = new THREE.RingGeometry(4 + i * 0.8, 4.1 + i * 0.8, 64);
                    const material = new THREE.MeshBasicMaterial({
                        color: 0xffffff,
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0
                    });
                    const ring = new THREE.Mesh(geometry, material);
                    ring.rotation.x = Math.PI / 2 + (i * Math.PI / 8);
                    ring.rotation.y = i * Math.PI / 6;
                    ring.position.z = -4;
                    this.rings.push(ring);
                    this.group.add(ring);
                }
                
                scene.add(this.group);
                this.group.visible = false;
            }
            
            update(audioLevel, bassLevel) {
                this.rings.forEach((ring, i) => {
                    ring.rotation.z += 0.003 * (i % 2 === 0 ? 1 : -1);
                    const scale = 1 + bassLevel * 0.1;
                    ring.scale.set(scale, scale, 1);
                    ring.material.opacity = 0.15 + audioLevel * 0.25;
                });
            }
            
            fadeIn(duration = 2) {
                this.group.visible = true;
                return new Promise(resolve => {
                    const start = performance.now();
                    const tick = () => {
                        const elapsed = (performance.now() - start) / 1000;
                        const progress = Math.min(1, elapsed / duration);
                        this.rings.forEach(ring => {
                            ring.material.opacity = progress * 0.2;
                        });
                        if (progress < 1) requestAnimationFrame(tick);
                        else resolve();
                    };
                    tick();
                });
            }
            
            fadeOut(duration = 2) {
                return new Promise(resolve => {
                    const start = performance.now();
                    const tick = () => {
                        const elapsed = (performance.now() - start) / 1000;
                        const progress = Math.min(1, elapsed / duration);
                        this.rings.forEach(ring => {
                            ring.material.opacity = (1 - progress) * 0.2;
                        });
                        if (progress < 1) {
                            requestAnimationFrame(tick);
                        } else {
                            this.group.visible = false;
                            resolve();
                        }
                    };
                    tick();
                });
            }
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = null; // Transparent - let the black body background show through unfiltered

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 3; // Zoomed out further for smaller appearance

            // Attach WebGL canvas inside #scene-root for reliable mobile z-ordering
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: 'high-performance' });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 0); // Transparent clear color
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('scene-root').appendChild(renderer.domElement);
            // iOS sometimes blocks pointer events through filtered parents; ensure canvas accepts taps
            renderer.domElement.style.touchAction = 'none';
            renderer.domElement.style.pointerEvents = 'auto';

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.enableZoom = false;
            controls.enablePan = false;

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
            scene.add(ambientLight);

            // Sunlight with shadows - store reference for music reactivity
            window.sunLight = new THREE.DirectionalLight(0xfff8e7, 1.0);
            window.sunLight.position.set(10, 10, 54);
            window.sunLight.castShadow = true;
            window.sunLight.shadow.mapSize.width = 2048;
            window.sunLight.shadow.mapSize.height = 2048;
            window.sunLight.shadow.camera.near = 0.5;
            window.sunLight.shadow.camera.far = 50;
            window.sunLight.shadow.camera.left = -10;
            window.sunLight.shadow.camera.right = 10;
            window.sunLight.shadow.camera.top = 10;
            window.sunLight.shadow.camera.bottom = -10;
            scene.add(window.sunLight);
            
            // Store ambient light reference too
            window.ambientLight = ambientLight;

            // Mouse and raycaster setup
            mouse = new THREE.Vector2();
            raycaster = new THREE.Raycaster();
            // Desktop hover
            window.addEventListener( 'mousemove', onMouseMove, false );
            // Mobile touch: map first touch point to mouse for hit testing
            window.addEventListener('touchstart', (e) => {
                if (!e.touches || e.touches.length === 0) return;
                const t = e.touches[0];
                mouse.x = ( t.clientX / window.innerWidth ) * 2 - 1;
                mouse.y = - ( t.clientY / window.innerHeight ) * 2 + 1;
                hoverEnabled = true;
            }, { passive: true });
            window.addEventListener('touchmove', (e) => {
                if (!e.touches || e.touches.length === 0) return;
                const t = e.touches[0];
                mouse.x = ( t.clientX / window.innerWidth ) * 2 - 1;
                mouse.y = - ( t.clientY / window.innerHeight ) * 2 + 1;
            }, { passive: true });

            // Initialize noise
            perlin = new NOISE.Perlin();
            perlin.init();
            perlin.noiseDetail(4, 0.5); // More detailed noise for realistic continents

            // --- Create the Planet ---
            planetGroup = new THREE.Group();
            scene.add(planetGroup);

            const planetRadius = 0.5; // Smaller planet
            const planetGeometry = new THREE.IcosahedronGeometry(planetRadius, 4); // Higher detail for better noise

            // Displace vertices for terrain
            const positionAttribute = planetGeometry.attributes.position;
            for (let i = 0; i < positionAttribute.count; i++) {
                const vertex = new THREE.Vector3().fromBufferAttribute(positionAttribute, i);
                const normalized = vertex.clone().normalize();
                const theta = Math.acos(normalized.y);
                const phi = Math.atan2(normalized.x, normalized.z);
                const noiseValue = perlin.noise(phi * 3, theta * 3); // Adjusted scale for continent size
                let height = 0;
                if (noiseValue > 0.4) { // Higher threshold for more water coverage
                    height = (noiseValue - 0.4) / 0.6 * 0.2; // Bulge up to 20% for cartoony exaggeration
                }
                vertex.multiplyScalar(1 + height);
                positionAttribute.setXYZ(i, vertex.x, vertex.y, vertex.z);
            }
            planetGeometry.computeVertexNormals();

            // Add vertex colors for ocean/land
            const colors = new Float32Array(positionAttribute.count * 3);
            for (let i = 0; i < positionAttribute.count; i++) {
                const vertex = new THREE.Vector3().fromBufferAttribute(positionAttribute, i);
                const len = vertex.length();
                const height = (len - planetRadius) / planetRadius;
                let color;
                if (height > 0) {
                    color = new THREE.Color(0x6a8c45); // Darker green land
                } else {
                    color = new THREE.Color(0x2e5a7a); // Darker blue ocean
                }
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
            }
            planetGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const planetMaterial = new THREE.MeshToonMaterial({ vertexColors: true });
            planetMesh = new THREE.Mesh(planetGeometry, planetMaterial);
            planetMesh.castShadow = true;
            planetMesh.receiveShadow = true;
            planetGroup.add(planetMesh);

            // Planet outline in peach color
            const planetOutlineMaterial = new THREE.MeshBasicMaterial({ color: 0xffdab9, side: THREE.BackSide });
            const outlineGeometry = planetGeometry.clone();
            outlineMesh = new THREE.Mesh(outlineGeometry, planetOutlineMaterial);
            outlineMesh.scale.setScalar(1.05); // Slightly larger for outline
            planetGroup.add(outlineMesh);

            // Clouds for cartoony atmosphere
            const cloudGeometry = new THREE.SphereGeometry(planetRadius * 1.01, 32, 16);
            const cloudPositionAttribute = cloudGeometry.attributes.position;
            for (let i = 0; i < cloudPositionAttribute.count; i++) {
                const vertex = new THREE.Vector3().fromBufferAttribute(cloudPositionAttribute, i);
                const normalized = vertex.clone().normalize();
                const theta = Math.acos(normalized.y);
                const phi = Math.atan2(normalized.x, normalized.z);
                const noiseValue = perlin.noise(phi * 8, theta * 8); // Higher frequency for fluffy clouds
                if (noiseValue > 0.6) {
                    const height = (noiseValue - 0.6) / 0.4 * 0.03; // Small puffs
                    vertex.multiplyScalar(1 + height);
                    cloudPositionAttribute.setXYZ(i, vertex.x, vertex.y, vertex.z);
                }
            }
            cloudGeometry.computeVertexNormals();

            const cloudMaterial = new THREE.MeshLambertMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.3
            });
            const clouds = new THREE.Mesh(cloudGeometry, cloudMaterial);
            clouds.castShadow = true;
            clouds.receiveShadow = true;
            planetGroup.add(clouds);

            // --- Create the Moon ---
            moonOrbit = new THREE.Group();
            scene.add(moonOrbit);

            const moonGroup = new THREE.Group();
            const moonRadius = 0.15; // Smaller moon to match scaled planet
            const moonGeometry = new THREE.IcosahedronGeometry(moonRadius, 2); // Lower poly moon

            const moonMaterial = new THREE.MeshToonMaterial({ color: 0xcccccc });
            const moonMesh = new THREE.Mesh(moonGeometry, moonMaterial);
            moonMesh.castShadow = true;
            moonMesh.receiveShadow = true;
            moonGroup.add(moonMesh);

            // Moon outline in light pastel blue
            const moonOutlineMaterial = new THREE.MeshBasicMaterial({ color: 0xadd8e6, side: THREE.BackSide });
            const moonOutline = new THREE.Mesh(moonGeometry, moonOutlineMaterial);
            moonOutline.scale.setScalar(1.1);
            moonGroup.add(moonOutline);
            moonOutlineRef = moonOutline;

            // Add craters to the moon
            function addCrater(parent, scale, position) {
                const craterGeometry = new THREE.SphereGeometry(moonRadius * scale, 8, 8);
                const craterMesh = new THREE.Mesh(craterGeometry, new THREE.MeshToonMaterial({ color: 0xaaaaaa }));
                craterMesh.position.copy(position).multiplyScalar(moonRadius * 0.9); // Push slightly inwards
                craterMesh.scale.set(1, 1, 0.2); // Flatten the sphere into a dish
                parent.add(craterMesh);

                const craterOutline = new THREE.Mesh(craterGeometry, new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.BackSide }));
                craterOutline.scale.set(1.1, 1.1, 0.25); // Outline for the crater
                craterOutline.position.copy(position).multiplyScalar(moonRadius * 0.9);
                parent.add(craterOutline);
            }

            // Generate some random craters
            for (let i = 0; i < 5; i++) {
                const craterSize = THREE.MathUtils.randFloat(0.15, 0.3);
                // Generate a random direction using spherical coordinates
                const pos = new THREE.Vector3();
                const phi = THREE.MathUtils.randFloat(0, Math.PI * 2); // Random angle around (0 to 360 degrees)
                const theta = Math.acos(THREE.MathUtils.randFloat(-1, 1)); // Random angle from pole (0 to 180 degrees)
                pos.setFromSphericalCoords(1, phi, theta); // Set vector from these angles

                addCrater(moonGroup, craterSize, pos);
            }

            moonGroup.position.x = 1.0; // Smaller orbit for smaller planet
            moonOrbit.add(moonGroup);
            
            // --- Initialize visualizations ---
            visualizations = [
                new RadialSpectrum(scene),
                new ParticleField(scene),
                new WireframeTorus(scene),
                new WaveformRing(scene),
                new GridDistortion(scene),
                new OrbitalRings(scene)
            ];
            // console.log('Initialized', visualizations.length, 'visualizations');

            // --- Create the Satellite (opposite side of the moon) ---
            satelliteOrbit = new THREE.Group();
            scene.add(satelliteOrbit);

            satelliteGroup = new THREE.Group();
            satelliteGroup.position.x = -1.0; // opposite the moon along X
            satelliteOrbit.add(satelliteGroup);

            const loader = new GLTFLoader();
            loader.load('./models/satellite.glb', (gltf) => {
                satelliteRoot = gltf.scene;
                // Normalize scale a bit for scene
                const desiredSize = 0.95; // approximate height
                const box = new THREE.Box3().setFromObject(satelliteRoot);
                const size = new THREE.Vector3();
                box.getSize(size);
                const maxDim = Math.max(size.x, size.y, size.z) || 1;
                const scale = desiredSize / maxDim;
                satelliteRoot.scale.setScalar(scale);

                // Enable shadows for satellite
                satelliteRoot.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });

                // Create satellite outline by cloning and scaling the actual satellite geometry
                const satelliteOutlineGeometry = satelliteRoot.clone();
                const outlineMaterials = []; // Store materials for color changes
                satelliteOutlineGeometry.traverse((child) => {
                    if (child.isMesh) {
                        const outlineMaterial = new THREE.MeshBasicMaterial({ color: 0xffdab9, side: THREE.BackSide });
                        child.material = outlineMaterial;
                        outlineMaterials.push(outlineMaterial);
                    }
                });
                satelliteOutlineGeometry.scale.set(0.22, 0.17, 0.19); // Squish in Z axis for flatter outline
                // Apply the same initial rotation as the actual satellite
                satelliteOutlineGeometry.rotation.y = -Math.PI / 2;
                satelliteGroup.add(satelliteOutlineGeometry);
                satelliteOutlineRef = { group: satelliteOutlineGeometry, materials: outlineMaterials };

                // Ensure +X faces away from the planet as it orbits
                // We'll rotate it so its local +X points from planet to satellite
                satelliteRoot.rotation.y = -Math.PI / 2; // align model's +X to point outward when group looks at planet
                satelliteGroup.add(satelliteRoot);
            });

            // Mobile touch and click event handlers - attach after canvas is in DOM
            renderer.domElement.addEventListener('click', onPlanetClick, { passive: true });
            renderer.domElement.addEventListener('touchend', (e) => {
                if (e.changedTouches && e.changedTouches.length === 1) {
                    onPlanetClick(e);
                }
            }, { passive: true });

            window.addEventListener('resize', onWindowResize, false);
            
            // Get references to music reactive overlay elements
            appRootElement = document.getElementById('app-root');
            // Get pseudo-elements via computed style (will manipulate via CSS variables instead)
            document.documentElement.style.setProperty('--red-brightness', '1');
            document.documentElement.style.setProperty('--glow-scale', '1');
            
            // Color cycling system for post-FX filter
            const colorPresets = [
                { name: 'red', rgb: '255, 0, 0' },
                { name: 'green', rgb: '0, 195, 80' },
                { name: 'purple', rgb: '100, 40, 235' },
                { name: 'blue', rgb: '10, 60, 255' }
            ];
            let currentColorIndex = 0;
            
            // Set initial color (red)
            document.documentElement.style.setProperty('--filter-color-rgb', colorPresets[0].rgb);
            
            function cycleColor(direction) {
                // direction: 1 for next, -1 for previous
                currentColorIndex = (currentColorIndex + direction + colorPresets.length) % colorPresets.length;
                const color = colorPresets[currentColorIndex];
                document.documentElement.style.setProperty('--filter-color-rgb', color.rgb);
                // console.log('Color changed to:', color.name);
            }
            
            // Add event listeners for color cycle buttons
            const btnColorPrev = document.getElementById('btn-color-prev');
            const btnColorNext = document.getElementById('btn-color-next');
            
            btnColorPrev?.addEventListener('click', (e) => {
                e.stopPropagation();
                cycleColor(-1);
            });
            
            btnColorNext?.addEventListener('click', (e) => {
                e.stopPropagation();
                cycleColor(1);
            });

            // Apply jitter to page title characters
            const titleChars = document.querySelectorAll('#page-title span');
            titleChars.forEach((char, i) => {
                const jx = (Math.random() * 4 - 1) * 2; // -3..3px
                const jy = (Math.random() * 4 - 1) * 2;
                const jr = (Math.random() * 4 - 1) * 2; // -2..2deg
                char.style.setProperty('--jx', jx + 'px');
                char.style.setProperty('--jy', jy + 'px');
                char.style.setProperty('--jr', jr + 'deg');
                char.style.animationDelay = (i * 0.2) + 's';
            });

            // --- Audio: staged playback ---
            // DON'T add postfx-on at start - we want normal colors first

            const pathLoop = './loop/nighttime_loop.mp3';
            const pathStatic = './loop/static.mp3';
            const baseStreamUrl = STREAM_URL; // Use the configured URL from the top of the script
            
            // Check for mixed content on page load
            const hasMixedContentIssue = checkMixedContent(baseStreamUrl);
            if (hasMixedContentIssue) {
                console.error('════════════════════════════════════════════════════════');
                console.error('🚨 AUDIO WILL NOT WORK - MIXED CONTENT BLOCKED 🚨');
                console.error('Your page is HTTPS but the radio stream is HTTP');
                console.error('Browsers block HTTP content on HTTPS pages for security');
                console.error('════════════════════════════════════════════════════════');
                console.error('SOLUTIONS (see STREAM_URL configuration at top of script):');
                console.error('1. Change STREAM_URL to use HTTPS if your server supports it');
                console.error('2. Use a CORS proxy: https://corsproxy.io/?http://your-stream-url');
                console.error('3. Set up a reverse proxy with HTTPS (e.g., Cloudflare, nginx)');
                console.error('4. Add HTTPS support to your Icecast/streaming server');
                console.error('════════════════════════════════════════════════════════');
                console.error('Current URL:', baseStreamUrl);
                console.error('Page protocol:', window.location.protocol);
                console.error('════════════════════════════════════════════════════════');
            }
            
            // Helper function to get fresh stream URL with cache-busting
            const getFreshStreamUrl = () => {
                try {
                    const url = `${baseStreamUrl}?t=${Date.now()}&nocache=${Math.random()}`;
                    // console.log('getFreshStreamUrl generated:', url);
                    if (hasMixedContentIssue) {
                        console.warn('⚠️ This URL will be BLOCKED by the browser (mixed content)');
                    }
                    return url;
                } catch (err) {
                    console.error('Error in getFreshStreamUrl:', err);
                    return baseStreamUrl; // Fallback to base URL
                }
            };

            audioLoop = new Audio(pathLoop);
            audioLoop.loop = true;
            audioLoop.volume = 0.03; // 3% - quiet ambient background
            audioLoop.crossOrigin = 'anonymous'; // Enable for Web Audio API
            audioLoop.preload = 'auto'; // iOS needs explicit preload

            audioStatic = new Audio(pathStatic);
            audioStatic.loop = false;
            audioStatic.volume = 1.0;
            audioStatic.preload = 'auto';

            audioStream = new Audio();
            audioStream.crossOrigin = 'anonymous'; // HTTPS stream works with CORS on iOS Safari now
            
            // iOS Safari audio configuration
            if (deviceInfo.isIOSSafari) {
                console.log('iOS Safari detected - applying audio fixes');
                audioStream.preload = 'metadata'; // iOS prefers metadata over auto for streams
                // Enable playsinline for iOS
                audioStream.setAttribute('playsinline', '');
                audioStream.setAttribute('webkit-playsinline', '');
                audioLoop.setAttribute('playsinline', '');
                audioLoop.setAttribute('webkit-playsinline', '');
                audioStatic.setAttribute('playsinline', '');
                audioStatic.setAttribute('webkit-playsinline', '');
                
                // Check MIME type support
                const mp3Support = audioStream.canPlayType('audio/mpeg');
                const mp3Support2 = audioStream.canPlayType('audio/mp3');
                console.log('iOS Safari audio/mpeg support:', mp3Support);
                console.log('iOS Safari audio/mp3 support:', mp3Support2);
                
                console.log('iOS Safari: Using crossOrigin with HTTPS stream');
            } else {
                audioStream.preload = 'none'; // Don't buffer ahead for live streams on other platforms
            }
            
            // Don't set initial URL - will be set when actually needed
            // console.log('Audio stream element created, will set URL on first use');
            
            // Stream health monitoring and recovery
            let streamStallTimer = null;
            let lastPlayPosition = 0;
            let streamCheckInterval = null;
            let streamRefreshInterval = null;
            let streamStartTime = Date.now();
            
            // Monitor stream health every 2 seconds
            const monitorStream = () => {
                if (!audioStream || audioStream.paused) return;
                
                const currentTime = audioStream.currentTime;
                
                // If position hasn't changed and we're supposed to be playing, we're stalled
                if (currentTime === lastPlayPosition && !audioStream.paused) {
                    console.warn('Stream stalled, attempting recovery with fresh URL...');
                    audioStream.src = getFreshStreamUrl(); // Get fresh stream URL
                    audioStream.load(); // Reload stream
                    audioStream.play().catch(() => {});
                }
                
                lastPlayPosition = currentTime;
            };
            
            // DISABLED: Auto-refresh causes audio dropouts/hitching
            // Live streams automatically stay on live edge via HTTP chunked transfer
            // Only refresh on actual stalls/errors (handled by monitorStream above)
            const refreshStreamConnection = () => {
                // Disabled - no periodic refresh needed for live streams
                return;
            };
            
            // Handle stream errors with detailed iOS Safari logging
            audioStream.addEventListener('error', (e) => {
                console.error('Stream error event:', e);
                
                // Check for mixed content blocking
                if (hasMixedContentIssue) {
                    console.error('🚨 ERROR LIKELY CAUSED BY MIXED CONTENT BLOCKING! 🚨');
                    console.error('The browser is blocking HTTP audio on your HTTPS page');
                    console.error('See the solutions logged above');
                }
                
                if (audioStream.error) {
                    console.error('Stream error code:', audioStream.error.code);
                    console.error('Stream error message:', audioStream.error.message);
                    // Error codes: 1=ABORTED, 2=NETWORK, 3=DECODE, 4=SRC_NOT_SUPPORTED
                    if (audioStream.error.code === 1) {
                        console.error('ABORTED ERROR - Likely mixed content or CORS issue');
                        if (hasMixedContentIssue) {
                            console.error('This is definitely a mixed content problem!');
                            return; // Don't try to recover, it won't work
                        }
                    } else if (audioStream.error.code === 2) {
                        console.error('NETWORK ERROR - Check CORS, connectivity, or server');
                        if (hasMixedContentIssue) {
                            console.error('Mixed content blocking detected!');
                            return; // Don't try to recover
                        }
                    } else if (audioStream.error.code === 4) {
                        console.error('SRC_NOT_SUPPORTED - Check MIME type or format');
                    }
                }
                
                if (deviceInfo.isIOSSafari) {
                    console.log('iOS Safari: Stream error detected, attempting recovery...');
                }
                
                // Don't attempt recovery if we have mixed content issues
                if (hasMixedContentIssue) {
                    console.error('Skipping recovery - mixed content cannot be fixed client-side');
                    return;
                }
                
                // Attempt to recover after a short delay with fresh URL
                setTimeout(() => {
                    if (audioStream && !audioStream.paused) {
                        console.log('Recovering stream with fresh URL...');
                        audioStream.src = getFreshStreamUrl();
                        audioStream.load();
                        audioStream.play().catch(() => {});
                    }
                }, 1000);
            });
            
            // Handle stalling/waiting
            audioStream.addEventListener('waiting', () => {
                console.warn('Stream buffering...');
                // If buffering takes too long, reload with fresh URL
                streamStallTimer = setTimeout(() => {
                    console.warn('Buffer stall timeout, reloading stream with fresh URL...');
                    audioStream.src = getFreshStreamUrl();
                    audioStream.load();
                    audioStream.play().catch(() => {});
                }, 5000); // 5 second timeout
            });
            
            audioStream.addEventListener('playing', () => {
                // Clear stall timer when playing resumes
                if (streamStallTimer) {
                    clearTimeout(streamStallTimer);
                    streamStallTimer = null;
                }
                // Start monitoring for stalls (every 2 seconds)
                if (!streamCheckInterval) {
                    streamCheckInterval = setInterval(monitorStream, 2000);
                }
                // Note: Removed periodic refresh - it caused audio dropouts
                // Live streams stay on edge automatically via HTTP streaming
            });
            
            audioStream.addEventListener('pause', () => {
                // Stop monitoring when paused
                if (streamCheckInterval) {
                    clearInterval(streamCheckInterval);
                    streamCheckInterval = null;
                }
            });
            
            // Stream event listeners (debug logs commented out to reduce console spam)
            audioStream.addEventListener('loadstart', () => {
                // console.log('Stream loading started:', audioStream.src);
                // console.log('Stream connected to analyser:', !!streamSource);
            });
            
            audioStream.addEventListener('loadedmetadata', () => {
                // console.log('Stream metadata loaded successfully');
            });
            
            audioStream.addEventListener('canplay', () => {
                // console.log('Stream can play - data available');
            });
            
            audioStream.addEventListener('play', () => {
                // console.log('Stream play event - stream is playing');
                // Check audio setup after stream starts (commented out to reduce spam)
                // setTimeout(() => { checkAudioSetup(); }, 1000);
            });
            
            // Additional iOS debugging events (commented out to reduce console spam)
            // if (deviceInfo.isIOSSafari) {
            //     audioStream.addEventListener('loadeddata', () => {
            //         console.log('iOS Safari: loadeddata - first frame loaded');
            //     });
            //     audioStream.addEventListener('canplaythrough', () => {
            //         console.log('iOS Safari: canplaythrough - can play without buffering');
            //     });
            //     audioStream.addEventListener('progress', () => {
            //         console.log('iOS Safari: progress - downloading...');
            //     });
            //     audioStream.addEventListener('suspend', () => {
            //         console.log('iOS Safari: suspend - download suspended');
            //     });
            //     audioStream.addEventListener('stalled', () => {
            //         console.log('iOS Safari: stalled - download stalled');
            //     });
            //     audioStream.addEventListener('abort', () => {
            //         console.log('iOS Safari: abort - download aborted');
            //     });
            //     audioStream.addEventListener('emptied', () => {
            //         console.log('iOS Safari: emptied - media element reset');
            //     });
            // }
            
            // Expose debug function to window for manual testing
            window.checkAudioSetup = checkAudioSetup;
            
            // iOS Safari: Comprehensive diagnostic function
            if (deviceInfo.isIOSSafari) {
                window.diagnoseIOSAudio = () => {
                    console.log('=== iOS Safari Audio Diagnostics ===');
                    console.log('Device Info:', deviceInfo);
                    console.log('Audio Stream State:', {
                        src: audioStream.src,
                        paused: audioStream.paused,
                        ended: audioStream.ended,
                        currentTime: audioStream.currentTime,
                        duration: audioStream.duration,
                        volume: audioStream.volume,
                        muted: audioStream.muted,
                        readyState: audioStream.readyState,
                        networkState: audioStream.networkState,
                        error: audioStream.error ? {
                            code: audioStream.error.code,
                            message: audioStream.error.message
                        } : null
                    });
                    console.log('AudioContext:', audioContext ? {
                        state: audioContext.state,
                        sampleRate: audioContext.sampleRate
                    } : 'Not initialized');
                    console.log('Stream Source:', streamSource);
                    console.log('Can Play Types:', {
                        'audio/mpeg': audioStream.canPlayType('audio/mpeg'),
                        'audio/mp3': audioStream.canPlayType('audio/mp3'),
                        'audio/mpeg;codecs=mp3': audioStream.canPlayType('audio/mpeg;codecs=mp3')
                    });
                    console.log('Page Protocol:', window.location.protocol);
                    console.log('Stream URL Protocol:', audioStream.src ? new URL(audioStream.src).protocol : 'none');
                    console.log('=== End Diagnostics ===');
                };
                console.log('iOS Safari: Run window.diagnoseIOSAudio() in console for detailed diagnostics');
            }

            // Try autoplay, show prompt if blocked
            let audioEnabled = false;
            const promptOverlay = document.getElementById('autoplay-prompt');
            const enableBtn = document.getElementById('enable-audio');
            
            const startAudio = () => {
                audioEnabled = true;
                
                // Initialize Web Audio API for visualization (only once)
                if (!audioContext) {
                    try {
                        setupAudioVisualization(audioLoop, 'ambient loop');
                        // Resume audio context if suspended - critical for iOS Safari
                        if (audioContext.state === 'suspended') {
                            audioContext.resume().then(() => {
                                console.log('AudioContext resumed');
                                // iOS Safari: Ensure all audio elements are ready after resume
                                if (deviceInfo.isIOSSafari) {
                                    console.log('iOS Safari: AudioContext resumed after user interaction');
                                }
                            });
                        }
                    } catch (err) {
                        console.warn('Could not setup audio visualization:', err);
                    }
                }
                
                // iOS Safari: Explicit play attempt for all audio elements after user gesture
                if (deviceInfo.isIOSSafari) {
                    // Touch all audio elements to initialize them with user gesture
                    [audioLoop, audioStatic, audioStream].forEach(audio => {
                        if (audio) {
                            audio.load(); // Reload to ensure iOS recognizes user gesture
                        }
                    });
                    
                    // iOS Safari sometimes ignores initial volume settings, re-set them after user interaction
                    console.log('iOS Safari: Re-setting volumes after user gesture');
                    audioLoop.volume = 0.03; // 3% for ambient loop
                    audioStatic.volume = 1.0; // 100% for static (will be set to 0.6 later)
                    audioStream.volume = 0; // Start at 0 for fade-in
                    console.log('iOS Safari: Volumes set - Loop:', audioLoop.volume, 'Static:', audioStatic.volume, 'Stream:', audioStream.volume);
                }
                
                // PRELOAD STREAM EARLY - connect and start buffering at 0 volume
                if (!streamSource && audioContext) {
                    try {
                        console.log('Early stream preload: Connecting stream to analyser...');
                        streamSource = setupAudioVisualization(audioStream, 'radio stream');
                        
                        // Set URL and start loading immediately
                        audioStream.src = getFreshStreamUrl();
                        console.log('Early stream preload: URL set, loading stream...');
                        audioStream.load();
                        
                        // Start playing silently in background to buffer
                        audioStream.volume = 0;
                        audioStream.play().then(() => {
                            console.log('Stream preloaded and buffering in background at 0 volume');
                            if (deviceInfo.isIOSSafari) {
                                console.log('iOS Safari: Stream preloaded successfully with HTTPS');
                            }
                        }).catch(err => {
                            console.warn('Early stream preload play failed:', err);
                            if (deviceInfo.isIOSSafari) {
                                console.warn('iOS Safari: May need user interaction to start audio');
                            }
                        });
                    } catch (err) {
                        console.error('Early stream preload failed:', err);
                    }
                }
                
                audioLoop.play().catch(() => {});
                // Hide prompt with fade out
                promptOverlay?.classList.remove('show');
            };
            
            // Try silent autoplay test
            audioLoop.play().then(() => {
                // Autoplay succeeded! Audio is enabled
                audioEnabled = true;
                // console.log('Autoplay allowed by browser');
                
                // Initialize Web Audio API for visualization
                if (!audioContext) {
                    try {
                        setupAudioVisualization(audioLoop, 'ambient loop');
                        // Resume audio context if suspended
                        if (audioContext && audioContext.state === 'suspended') {
                            audioContext.resume().then(() => {
                                console.log('AudioContext resumed after autoplay');
                            });
                        }
                    } catch (err) {
                        console.warn('Could not setup audio visualization:', err);
                    }
                }
                
                // PRELOAD STREAM EARLY on autoplay success too
                if (!streamSource && audioContext) {
                    try {
                        console.log('Early stream preload (autoplay): Connecting stream to analyser...');
                        streamSource = setupAudioVisualization(audioStream, 'radio stream');
                        
                        // Set URL and start loading immediately
                        audioStream.src = getFreshStreamUrl();
                        console.log('Early stream preload (autoplay): URL set, loading stream...');
                        audioStream.load();
                        
                        // Start playing silently in background to buffer
                        audioStream.volume = 0;
                        audioStream.play().then(() => {
                            console.log('Stream preloaded and buffering in background at 0 volume (autoplay path)');
                            if (deviceInfo.isIOSSafari) {
                                console.log('iOS Safari (autoplay): Stream preloaded successfully with HTTPS');
                            }
                        }).catch(err => {
                            console.warn('Early stream preload play failed (autoplay):', err);
                            if (deviceInfo.isIOSSafari) {
                                console.warn('iOS Safari (autoplay): May need user interaction to start audio');
                            }
                        });
                    } catch (err) {
                        console.error('Early stream preload failed (autoplay):', err);
                    }
                }
            }).catch(() => {
                // Autoplay blocked - show our custom prompt
                // console.log('Autoplay blocked, showing prompt');
                promptOverlay?.classList.add('show');
            });
            
            // Handle enable audio button
            enableBtn?.addEventListener('click', () => {
                startAudio();
            });

            // Controls
            const btnPlay = document.getElementById('btn-play');
            const btnPause = document.getElementById('btn-pause');
            const btnDiscord = document.getElementById('btn-discord');
            const volSlider = document.getElementById('volume-slider');

            const setRadioVolumeFromSlider = () => {
                const v = Number(volSlider?.value ?? 35); // default 35
                const scaled = Math.min(1, Math.max(0, (v / 100) * radioScale));
                audioStream.volume = scaled;
            };
            setRadioVolumeFromSlider();

            btnPlay?.addEventListener('click', (e) => {
                e.stopPropagation();
                
                // console.log('Play button clicked');
                
                // Ensure audio context is running - critical for iOS Safari
                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume().then(() => {
                        console.log('AudioContext resumed on play button');
                    });
                }
                
                // If stream hasn't been connected yet, connect it first
                if (audioContext && !streamSource) {
                    try {
                        console.log('First play - connecting stream to analyser...');
                        streamSource = setupAudioVisualization(audioStream, 'radio stream');
                        console.log('Stream connected successfully');
                        if (deviceInfo.isIOSSafari) {
                            console.log('iOS Safari: Stream connected to Web Audio API with HTTPS');
                        }
                    } catch (err) {
                        console.error('Failed to connect stream:', err);
                    }
                }
                
                // Get fresh stream URL before playing to ensure live stream
                if (audioStream.paused || !audioStream.src || audioStream.src === window.location.href) {
                    console.log('Play button: Getting fresh stream URL');
                    audioStream.src = getFreshStreamUrl();
                    console.log('New stream URL:', audioStream.src);
                    
                    // iOS Safari: Explicit MIME type and load
                    if (deviceInfo.isIOSSafari) {
                        console.log('iOS Safari: Setting up stream with explicit MIME type');
                        // Create a new Audio element if needed for iOS Safari
                        const canPlayMp3 = audioStream.canPlayType('audio/mpeg');
                        console.log('iOS Safari can play audio/mpeg:', canPlayMp3);
                    }
                    
                    audioStream.load();
                }
                
                // iOS Safari: Set volume before playing to ensure audio pipeline is ready
                if (deviceInfo.isIOSSafari) {
                    const currentVolume = audioStream.volume;
                    audioStream.volume = currentVolume; // Re-set to ensure iOS registers it
                    console.log('iOS Safari: Stream volume before play:', audioStream.volume);
                }
                
                audioStream.play().then(() => {
                    console.log('Stream playing successfully');
                    if (deviceInfo.isIOSSafari) {
                        console.log('iOS Safari: Stream playback confirmed, volume:', audioStream.volume);
                        // Ensure volume is correct after play starts
                        setRadioVolumeFromSlider();
                        console.log('iOS Safari: Volume re-applied from slider:', audioStream.volume);
                    }
                }).catch((err) => {
                    console.error('Play failed:', err);
                    // iOS Safari: Try alternative approach
                    if (deviceInfo.isIOSSafari) {
                        console.log('iOS Safari: Retrying playback after error...');
                        setTimeout(() => {
                            audioStream.load();
                            audioStream.play().then(() => {
                                console.log('iOS Safari: Retry successful');
                                setRadioVolumeFromSlider();
                            }).catch(e => console.error('iOS Safari retry failed:', e));
                        }, 500);
                    }
                });
            });
            btnPause?.addEventListener('click', (e) => {
                e.stopPropagation();
                audioStream.pause();
            });
            volSlider?.addEventListener('input', (e) => {
                e.stopPropagation();
                setRadioVolumeFromSlider();
            });
            btnDiscord?.addEventListener('click', (e) => {
                e.stopPropagation();
                window.open('https://discord.com/invite/your-server', '_blank', 'noopener');
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function screenPositionOfObject(obj, camera) {
            const vector = new THREE.Vector3();
            obj.getWorldPosition(vector);
            vector.project(camera);
            const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
            return { x, y, behind: vector.z > 1 };
        }

        let uiVisible = false;
        let hasBeenActivated = false; // Track if we've done the initial activation
        
        function onPlanetClick(event) {
            // Basic raycast to ensure planet was clicked
            let cx, cy;
            // For touch events, use changedTouches instead of touches for touchend
            if (event.changedTouches && event.changedTouches.length) {
                cx = event.changedTouches[0].clientX;
                cy = event.changedTouches[0].clientY;
            } else if (event.touches && event.touches.length) {
                cx = event.touches[0].clientX;
                cy = event.touches[0].clientY;
            } else {
                cx = event.clientX;
                cy = event.clientY;
            }
            const mouseNDC = new THREE.Vector2(
                ( cx / window.innerWidth ) * 2 - 1,
                - ( cy / window.innerHeight ) * 2 + 1
            );
            raycaster.setFromCamera(mouseNDC, camera);
            const hit = raycaster.intersectObject(planetMesh);
            if (!hit.length) return;

            uiVisible = !uiVisible;
            const ui = document.getElementById('ui-layer');
            ui.setAttribute('aria-hidden', String(!uiVisible));
            ui.classList.toggle('show', uiVisible);
            const accent = uiVisible ? 0xff4d2e : 0xffdab9;
            outlineMesh.material.color.setHex(accent); // planet
            if (moonOutlineRef) moonOutlineRef.material.color.setHex(accent); // moon

            // Check if this is the first time opening (before setting hasBeenActivated)
            const isFirstActivation = uiVisible && !hasBeenActivated;
            
            // console.log('Planet clicked - uiVisible:', uiVisible, 'hasBeenActivated:', hasBeenActivated, 'isFirstActivation:', isFirstActivation);
            
            // ADD postfx on FIRST activation only, keep it on forever after
            if (isFirstActivation) {
                const appRootEl = document.getElementById('app-root');
                appRootEl?.classList.add('postfx-on');
                hasBeenActivated = true;
                // console.log('Set hasBeenActivated to true');
                
                // Ensure audio context is running for visualizations
                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume().then(() => {
                        console.log('AudioContext resumed on first planet activation');
                    });
                }
            }

            // prepare letter jitter spans once when showing
            if (uiVisible) {
                const labels = document.querySelectorAll('#ui-layer .letters');
                labels.forEach(label => {
                    // If already processed, skip
                    if (label.dataset.split === '1') return;

                    const text = label.textContent || '';
                    label.textContent = '';
                    [...text].forEach((ch, i) => {
                        const span = document.createElement('span');
                        span.textContent = ch;
                        // random small offsets/rotation and stagger
                        const jx = (Math.random() * 2- 1) * 1; // -1.5..1.5px
                        const jy = (Math.random() * 2 - 1) * 1;
                        const jr = (Math.random() * 2 - 1) * 2;   // -2..2deg
                        span.style.setProperty('--jx', jx + 'px');
                        span.style.setProperty('--jy', jy + 'px');
                        span.style.setProperty('--jr', jr + 'deg');
                        span.style.animationDelay = (i * 0.03) + 's';
                        label.appendChild(span);
                    });
                    label.dataset.split = '1';
                });
            }

            // Transition audio on FIRST activation only
            if (isFirstActivation) {
                // console.log('FIRST ACTIVATION - Starting audio transition');
                const appRootEl = document.getElementById('app-root');
                
                // CRITICAL FOR MOBILE: Start stream playing NOW (synchronously) to preserve user gesture
                // This must happen directly in the click handler, not in an async callback
                if (audioStream) {
                    // console.log('MOBILE: Starting stream synchronously on user click...');
                    
                    // Set up stream if not already set
                    if (!audioStream.src || audioStream.src === window.location.href) {
                        // console.log('MOBILE: Setting stream URL synchronously...');
                        audioStream.src = getFreshStreamUrl();
                        audioStream.load();
                        
                        // Connect to Web Audio API if needed
                        if (audioContext && !streamSource) {
                            try {
                                streamSource = setupAudioVisualization(audioStream, 'radio stream');
                                // console.log('MOBILE: Stream connected to Web Audio API');
                            } catch (err) {
                                console.warn('MOBILE: Could not connect to Web Audio API:', err);
                            }
                        }
                    }
                    
                    // Start playing at 0 volume immediately (synchronously!)
                    audioStream.volume = 0;
                    audioStream.play().then(() => {
                        // console.log('MOBILE: Stream started successfully in click handler');
                    }).catch(err => {
                        console.error('MOBILE: Failed to start stream in click handler:', err);
                    });
                }
                
                // Helper: fade out audio
                const fadeOut = (audio, ms = 300) => new Promise(resolve => {
                    if (!audio) { resolve(); return; }
                    const start = audio.volume;
                    const t0 = performance.now();
                    const tick = () => {
                        const dt = performance.now() - t0;
                        const k = Math.min(1, dt / ms);
                        audio.volume = start * (1 - k);
                        if (k < 1) requestAnimationFrame(tick); 
                        else { 
                            audio.pause(); 
                            resolve(); 
                        }
                    };
                    tick();
                });
                
                // Helper: fade in audio
                const fadeIn = (audio, target = 0.35, ms = 300) => new Promise(resolve => {
                    // console.log('fadeIn called - target:', target, 'ms:', ms, 'audio paused:', audio?.paused);
                    if (!audio) { 
                        // console.log('fadeIn: no audio element provided');
                        resolve(); 
                        return; 
                    }
                    const startVol = audio.volume || 0.001;
                    // console.log('fadeIn: starting volume:', startVol);
                    
                    // Only call play if not already playing
                    if (audio.paused) {
                        // console.log('fadeIn: audio is paused, calling play()');
                        audio.volume = 0.001;
                        audio.play().catch((err) => {
                            console.error('fadeIn: play() failed:', err);
                        });
                    } else {
                        // console.log('fadeIn: audio already playing, just fading volume');
                    }
                    
                    const t0 = performance.now();
                    const tick = () => {
                        const dt = performance.now() - t0;
                        const k = Math.min(1, dt / ms);
                        audio.volume = startVol + (target - startVol) * k;
                        if (k < 1) {
                            requestAnimationFrame(tick);
                        } else {
                            // console.log('fadeIn: complete. Final volume:', audio.volume);
                            resolve();
                        }
                    };
                    tick();
                });

                // Execute audio sequence (postfx already added above for instant visual transition)
                (async () => {
                    try {
                        // 1. Fade out nighttime loop
                        if (audioLoop) await fadeOut(audioLoop, 250);
                        
                        // 2. Play static.mp3 once
                        if (audioStatic) {
                            // console.log('Playing static sound...');
                            audioStatic.volume = 0.6;
                            audioStatic.currentTime = 0;
                            const staticPromise = audioStatic.play();
                            // console.log('Static play() promise created');
                            
                            // Stream should already be playing at 0 volume from click handler
                            // Just verify it's ready
                            if (audioStream) {
                                // console.log('Checking stream status during static...');
                                // console.log('Stream paused?', audioStream.paused);
                                // console.log('Stream src:', audioStream.src || 'NOT SET');
                                // console.log('Stream current volume:', audioStream.volume);
                                
                                // Stream should be playing now - this is just a safety check
                                if (audioStream.paused) {
                                    console.warn('WARNING: Stream is paused during static - this should not happen');
                                    // console.log('Attempting to restart stream...');
                                    audioStream.volume = 0;
                                    await audioStream.play().catch(err => {
                                        console.error('Failed to restart paused stream:', err);
                                    });
                                } else {
                                    // console.log('Stream is playing as expected, ready for fade-in');
                                }
                            }
                            
                            // Wait for static to finish
                            try {
                                await staticPromise;
                                // console.log('Static play promise resolved, waiting for ended event...');
                                
                                // Wait for static to end, with a timeout fallback
                                const staticEnded = new Promise(res => audioStatic.addEventListener('ended', res, { once: true }));
                                const timeout = new Promise(res => setTimeout(() => {
                                    // console.warn('Static timeout - proceeding anyway after 1.5 seconds');
                                    res();
                                }, 1500));
                                
                                await Promise.race([staticEnded, timeout]);
                                // console.log('Static finished (either ended or timed out)');
                            } catch (err) {
                                console.error('Error waiting for static to finish:', err);
                            }
                        }
                        
                        // 3. Fade in radio stream volume (already playing at 0 from click handler!)
                        if (audioStream) {
                            // console.log('Starting stream fade-in sequence');
                            // console.log('Stream paused?', audioStream.paused, 'Current volume:', audioStream.volume);
                            
                            const volEl = document.getElementById('volume-slider');
                            const v = Number(volEl?.value ?? 35);
                            const target = Math.min(1, Math.max(0, (v / 100) * radioScale));
                            // console.log('Calculated target volume:', target);
                            
                            // Stream should already be playing from click handler
                            if (audioStream.paused) {
                                console.error('ERROR: Stream is paused when it should be playing!');
                                console.error('This means mobile user gesture was lost - stream may not play');
                            } else {
                                // console.log('Stream is playing, fading volume up...');
                            }
                            
                            // Fade up the volume (stream is already playing)
                            // console.log('Fading volume from', audioStream.volume, 'to', target);
                            await fadeIn(audioStream, target, 300);
                            // console.log('Stream fade-in complete. Final volume:', audioStream.volume);
                            
                            // if (deviceInfo.isMobile || deviceInfo.isIOSSafari) {
                            //     console.log('MOBILE: Final check - paused:', audioStream.paused, 'volume:', audioStream.volume);
                            // }
                        }
                        
                        // console.log('=== Audio Transition Complete ===');
                    } catch (err) {
                        console.error('Audio transition error:', err);
                        console.error('Error stack:', err.stack);
                    }
                })();
            }
        }


        function layoutBubbles() {
            if (!uiVisible) return;
            const ui = document.getElementById('ui-layer');
            const tl = ui.querySelector('.top-left');
            const tr = ui.querySelector('.top-right');
            const bl = ui.querySelector('.bottom-left');
            const br = ui.querySelector('.bottom-right');

            // Planet screen position
            const planetScreen = screenPositionOfObject(planetGroup, camera);

            const gap = Math.min(window.innerWidth, window.innerHeight) * (window.innerWidth < 540 ? 0.28 : 0.19); // further on phones

            // Position around planet
            tl.style.left = (planetScreen.x - gap) + 'px';
            tl.style.top  = (planetScreen.y - gap) + 'px';

            tr.style.left = (planetScreen.x + gap) + 'px';
            tr.style.top  = (planetScreen.y - gap) + 'px';

            bl.style.left = (planetScreen.x - gap) + 'px';
            bl.style.top  = (planetScreen.y + gap) + 'px';

            br.style.left = (planetScreen.x + gap) + 'px';
            br.style.top  = (planetScreen.y + gap) + 'px';
        }
        
        // Visualization transition system - randomized with no gaps
        async function transitionToNextVisualization() {
            if (isTransitioning || visualizations.length === 0) return;
            isTransitioning = true;
            
            const prevIndex = currentVisualizationIndex;
            
            // Pick a random visualization (but not the current one)
            let nextIndex;
            if (visualizations.length > 1) {
                do {
                    nextIndex = Math.floor(Math.random() * visualizations.length);
                } while (nextIndex === prevIndex);
            } else {
                nextIndex = 0;
            }
            
            // console.log(`Transitioning from visualization ${prevIndex} to ${nextIndex} (random)`);
            
            // Start next visualization immediately (no gap)
            visualizations[nextIndex].fadeIn(2.0);
            
            // Fade out current after a brief overlap for smooth transition
            setTimeout(() => {
                visualizations[prevIndex].fadeOut(1.5);
            }, 500); // 0.5 second overlap for seamless transition
            
            currentVisualizationIndex = nextIndex;
            visualizationTransitionTimer = 0;
            
            // Set a new random duration for the next visualization
            visualizationDuration = getRandomVisualizationDuration();
            // console.log(`Next visualization will last ${visualizationDuration.toFixed(1)} seconds`);
            
            // Mark as not transitioning after fade-in starts (allows updates immediately)
            setTimeout(() => {
                isTransitioning = false;
            }, 500);
        }
        
        // Start the visualization system (called when audio starts)
        let visualizationsStarted = false;
        function startVisualizations() {
            if (visualizationsStarted || visualizations.length === 0) return;
            
            // Pick a random starting visualization
            currentVisualizationIndex = Math.floor(Math.random() * visualizations.length);
            // console.log('Starting visualization system with random visualization:', currentVisualizationIndex);
            
            // Set initial random duration
            visualizationDuration = getRandomVisualizationDuration();
            // console.log(`First visualization will last ${visualizationDuration.toFixed(1)} seconds`);
            
            visualizations[currentVisualizationIndex].fadeIn(2);
            visualizationTransitionTimer = 0;
            visualizationsStarted = true;
        }

        function animate() {
            requestAnimationFrame(animate);

            // Raycast for hover detection only if mouse has moved
            let currentHovered = false;
            if (hoverEnabled) {
                raycaster.setFromCamera( mouse, camera );
                const intersects = raycaster.intersectObject( planetMesh );
                currentHovered = intersects.length > 0;
            }

            // Outline color: when UI is visible, force accent; otherwise use hover feedback
            const outlineColor = uiVisible ? 0xff5f02 : (currentHovered ? 0x333333 : 0xffdab9);
            outlineMesh.material.color.setHex(outlineColor);
            if (moonOutlineRef) moonOutlineRef.material.color.setHex(outlineColor);
            if (satelliteOutlineRef && satelliteOutlineRef.materials) {
                satelliteOutlineRef.materials.forEach(material => material.color.setHex(outlineColor));
            }

            // MUSIC REACTIVE SCALING - Get audio levels
            const bassLevel = getBassLevel();
            const audioLevel = getAudioLevel();
            const frequencyData = getFrequencyData();
            
            // Update all visible visualizations (allows smooth transitions with overlap)
            if (hasBeenActivated && visualizations.length > 0 && visualizationsStarted) {
                // Update any visible visualization (not just current one)
                visualizations.forEach(vis => {
                    const isVisible = vis.group?.visible || 
                                     vis.particles?.visible || 
                                     vis.line?.visible || 
                                     vis.grid?.visible ||
                                     false;
                    
                    if (isVisible) {
                        vis.update(audioLevel, bassLevel, frequencyData);
                    }
                });
                
                // Timer for automatic transitions (only increment when not transitioning)
                if (!isTransitioning) {
                    visualizationTransitionTimer += 1/60; // Assuming 60 FPS
                    if (visualizationTransitionTimer >= visualizationDuration) {
                        transitionToNextVisualization();
                    }
                }
            }
            
            // Combine bass (for punch) and overall level (for smoothness)
            const reactiveScale = 1 + (bassLevel * 0.06) + (audioLevel * 0.09);
            
            // MUSIC REACTIVE POST-FX & LIGHTING (higher threshold for stage light effect)
            // Activate after first planet click (hasBeenActivated), regardless of UI visibility
            if (hasBeenActivated) {
                // Start visualizations if not already started
                startVisualizations();
                
                // Update visualization colors and effects
                // Red filter brightness - pulse with bass (0.8 to 1.3 range)
                const redBrightness = 0.85 + (bassLevel * 0.05) + (audioLevel * 0.05);
                document.documentElement.style.setProperty('--red-brightness', redBrightness.toFixed(3));
                
                // Glow scale - expand with strong beats (0.95 to 1.15 range)
                const glowScale = 0.98 + (bassLevel * 0.12) + (audioLevel * 0.06);
                document.documentElement.style.setProperty('--glow-scale', glowScale.toFixed(3));
                
                // 3D Scene lighting - dim/brighten like stage lights
                if (window.sunLight) {
                    // Base intensity 1.0, pulse up to 1.5 on beats
                    window.sunLight.intensity = 1.0 + (bassLevel * 0.2) + (audioLevel * 0.2);
                }
                if (window.ambientLight) {
                    // Base 0.3, pulse up to 0.5 on beats
                    window.ambientLight.intensity = 0.3 + (bassLevel * 0.05) + (audioLevel * 0.08);
                }
            } else {
                // Before first activation - use default lighting
                document.documentElement.style.setProperty('--red-brightness', '1');
                document.documentElement.style.setProperty('--glow-scale', '1');
                if (window.sunLight) window.sunLight.intensity = 0.3;
                if (window.ambientLight) window.ambientLight.intensity = 0.3;
            }
            
            // Bounce animation: trigger once on hover enter (state change)
            if (currentHovered && !wasHovered && !animating) {
                animating = true;
                animationStartTime = performance.now() * 0.001;
            }

            if (animating) {
                const elapsed = performance.now() * 0.001 - animationStartTime;
                if (elapsed < animationDuration) {
                    const progress = elapsed / animationDuration;
                    const bounceScale = 1 + 0.05 * Math.sin( Math.PI * progress ); // One full grow-shrink cycle
                    // Apply both bounce AND music reactivity
                    const finalScale = bounceScale * reactiveScale;
                    planetGroup.scale.set( finalScale, finalScale, finalScale );
                } else {
                    animating = false;
                    planetGroup.scale.set( reactiveScale, reactiveScale, reactiveScale );
                }
            } else {
                // Apply music reactivity when not bouncing
                planetGroup.scale.set( reactiveScale, reactiveScale, reactiveScale );
            }

            // Update previous state
            wasHovered = currentHovered;

            planetGroup.rotation.y += 0.005; // Slightly faster spin
            planetGroup.rotation.x += 0.0008;

            moonOrbit.rotation.y += 0.015; // Faster moon orbit
            moonOrbit.children[0].rotation.y += 0.008; // Faster moon spin

            // Satellite orbit (same speed magnitude, opposite direction)
            if (satelliteOrbit) {
                satelliteOrbit.rotation.y += 0.015;
                if (satelliteGroup) {
                    // keep satellite oriented so its +X points away from planet
                    // by making the group's forward look at the planet, then rotate child so +X faces out
                    satelliteGroup.lookAt(planetGroup.position);
                    if (satelliteRoot) {
                        satelliteRoot.rotation.y = -Math.PI / 2; // maintain outward +X relative to group's lookAt
                    }
                }
            }

            layoutBubbles();
            controls.update();
            renderer.render(scene, camera);
        }

        init();
        animate();
    </script>

</body>

</html>
