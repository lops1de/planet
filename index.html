<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>dumpradio</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        html, body {
            height: 100%;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: #000000;
            /* Solid black background - stays unfiltered */
            font-family: 'Inter', sans-serif;
            /* Post FX applied on #app-root for better mobile compatibility */
        }
        
        /* Pure black background layer that doesn't receive filters */
        body::before {
            content: '';
            position: fixed;
            inset: 0;
            background: #000000;
            z-index: -2;
        }


        canvas {
            display: block;
        }

        /* Background particles removed */

        /* App root that receives post-processing filter on all content */
        #app-root {
            position: fixed;
            inset: 0;
        }
        
        /* Universal post-processing using CSS filters (works on all platforms) */
        #scene-root, #ui-layer {
            filter: saturate(3) contrast(2) brightness(1) invert(1);
            -webkit-filter: saturate(2) contrast(2) brightness(2) ;
        }
        
        /* Red screen overlay - vibrant neon red (multiply layer to darken inverted background) */
        #app-root::after {
            content: '';
            position: fixed;
            inset: 0;
            background: radial-gradient(ellipse at center, 
                rgba(255, 0, 0, 0.95) 0%, 
                rgb(255, 0, 0) 50%,
                rgb(255, 0, 0) 100%);
            mix-blend-mode:darken;
            pointer-events: none;
            z-index: 100;
        }
        
        /* Additional glow layer for neon effect */
        #app-root::before {
            content: '';
            position: fixed;
            inset: 0;
            background: radial-gradient(ellipse at center, 
                transparent 0%, 
                rgb(0, 0, 0) 100%,
                transparent 100%);
            mix-blend-mode: screen;
            pointer-events: none;
            z-index: 99;
            filter: blur(40px);
            -webkit-filter: blur(40px);
        }

        /* Hosting container for the WebGL canvas to make mobile layering explicit */
        #scene-root {
            position: absolute;
            inset: 0;
            z-index: 0;
            /* Transparent background so body black shows through unfiltered */
            background: transparent;
        }
        
        /* Make the WebGL canvas transparent so black background shows through */
        #scene-root canvas {
            background: transparent !important;
        }

        /* Ensure canvas always scales to viewport on mobile */
        #scene-root canvas {
            width: 100% !important;
            height: 100% !important;
            display: block;
        }

        /* Ensure background stays pure black - override any inherited filters */
        body, body::before {
            filter: none !important;
            -webkit-filter: none !important;
        }



        /* Page title */
        #page-title {
            position: fixed;
            top: 2vh;
            left: 50%;
            transform: translateX(-50%);
            font-size: clamp(48px, 12vw, 120px);
            font-weight: 900;
            letter-spacing: 0.3em;
            color: #ffffff;
            text-transform: lowercase;
            pointer-events: none;
            z-index: 15;
            user-select: none;
            /* Title should also be filtered for consistency */
            filter: saturate(16) contrast(1) brightness(1) invert(1);
            -webkit-filter: saturate(1) contrast(1) brightness(1) invert(1);
        }
        
        /* Mobile-specific title scaling */
        body.mobile #page-title {
            font-size: clamp(32px, 8vw, 70px);
            letter-spacing: 0.2em;
            white-space: nowrap;
        }
        
        #page-title span {
            display: inline-block;
            animation: titleJitter 4s linear infinite;
            font-family:monospace;
            font-size:20px;
        }
        
        /* Mobile-specific title character size */
        body.mobile #page-title span {
            font-size: 14px;
        }
        
        @keyframes titleJitter {
            0%, 100% {
                transform: translate(var(--jx, 0), var(--jy, 0)) rotate(var(--jr, 0));
            }
            50% {
                transform: translate(calc(var(--jx, 0) * -0.5), calc(var(--jy, 0) * -0.5)) rotate(calc(var(--jr, 0) * -0.5));
            }
        }
        
        /* Autoplay prompt overlay */
        #autoplay-prompt {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        
        #autoplay-prompt.show {
            opacity: 1;
            pointer-events: auto;
        }
        
        #autoplay-prompt .prompt-content {
            background: #1a1a1a;
            border: 3px solid #ffffff;
            padding: 40px 50px;
            text-align: center;
            max-width: 500px;
            color: #ffffff;
            font-family: monospace;
            box-shadow: 0 0 40px rgba(255, 255, 255, 0.2);
        }
        
        #autoplay-prompt h2 {
            margin: 0 0 20px 0;
            font-size: 24px;
            letter-spacing: 2px;
            text-transform: uppercase;
        }
        
        #autoplay-prompt p {
            margin: 0 0 30px 0;
            font-size: 14px;
            line-height: 1.6;
            opacity: 0.8;
        }
        
        #autoplay-prompt button {
            background: #ffffff;
            color: #000000;
            border: none;
            padding: 15px 40px;
            font-size: 16px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            cursor: pointer;
            font-family: monospace;
            transition: all 0.2s ease;
        }
        
        #autoplay-prompt button:hover {
            background: #ff5f02;
            color: #ffffff;
            transform: scale(1.05);
        }

        /* Persona/Katamari inspired UI layer */
        #ui-layer {
            position: fixed;
            inset: 0;
            pointer-events: none; /* let canvas keep receiving drags */
            z-index: 10; /* stay above the canvas */
        }

        #ui-layer.show .speech-bubble {
            opacity: 1;
            transform: translate(-50%, -50%) rotate(var(--rot, 0deg)) scale(1);
        }

        .speech-bubble {
            position: absolute;
            width: clamp(175px, 26vw, 240px);
            min-height: 64px;
            color: #000000;
            font-weight: 1000;
            letter-spacing: 0.8px;
            text-transform: uppercase;
            background: #fff8ea;
            --accent: #ff5724d8; /* Persona/Katamari orange-red */
            /* jaggy comic panel */
            --path: polygon(6% 0, 18% 6%, 34% 2%, 56% 8%, 74% 2%, 90% 9%, 100% 6%,
                           96% 26%, 100% 46%, 96% 70%, 100% 96%, 74% 100%, 52% 96%,
                           30% 100%, 8% 96%, 4% 72%, 0 52%, 5% 28%);
            clip-path: var(--path);
            padding: 2cqb 20px;
            border: none; /* border is drawn by ::before */
            outline: none;
            box-shadow: 0 10px 0 rgba(255, 72, 72, 0.25);
            transform: translate(-50%, -50%) rotate(var(--rot, 0deg)) scale(0.96);
            opacity: 0;
            transition: opacity 160ms ease, transform 200ms cubic-bezier(.2,.9,.2,1);
            pointer-events: auto; /* clickable buttons */
            cursor: pointer;
            user-select: none;
            animation: floaty 3.2s ease-in-out infinite, warble 4s ease-in-out infinite;
            z-index: 1; /* create a local stacking context for ::before/::after */
        }

        .speech-bubble::before { /* thick black border following the jaggy shape */
            content: "";
            position: absolute;
            inset: -6px;
            background: #ff5f02;
            clip-path: var(--path);
            z-index: -1;
        }

        /* Hard dropshadow in accent color (no blur) */
        .speech-bubble::after {
            content: "";
            position: absolute;
            inset: 0px; /* expanded from default for bigger silhouette */
            background: var(--accent);
            clip-path: var(--path);
            transform: translate(2px, 0px) scale(0.9); /* larger hard offset + size */
            z-index: -1; /* behind bubble but above canvas */
        }

        .speech-bubble:hover {
            transform: translate(-50%, -50%) rotate(var(--rot, 0deg)) scale(1.08) translateY(-2px);
            box-shadow: 0 15px 35px rgba(255, 72, 72, 0.4);
            background: #ff5724d8;
            color: #ff5f02;
            animation-play-state: paused;
            width: clamp(145px, 38vw, 240px);
        }

        .speech-bubble:hover::before {
            background: #ffffff;
        }

        .speech-bubble:hover::after {
            background: #ffffff;
        }

        .speech-bubble:active {
            transform: translate(-50%, -50%) rotate(var(--rot, 0deg)) scale(2.98) translateY(1px);
            transition: all 0.1s ease;
        }

        /* Jittered per-letter text */
        .speech-bubble .letters span {
            display: inline-block;
            will-change: transform;
            animation: jitter 2s linear infinite;
            font-size: 1.8em;
        }

        @keyframes jitter {
            0%, 100% { transform: translate(0, 0) rotate(0deg); }
            30% { transform: translate(var(--jx, 1px), var(--jy, -1px)) rotate(var(--jr, 1deg)); }
            60% { transform: translate(calc(var(--jx, 1px) * -1), calc(var(--jy, 1px) * -1)) rotate(calc(var(--jr, 1deg) * -1)); }
        }

        @keyframes warble {
            0%, 100% { transform: translate(-50%, -50%) rotate(var(--rot, 0deg)) scale(0.96) rotate(0deg); }
            25% { transform: translate(-50%, -50%) rotate(var(--rot, 0deg)) scale(0.98) rotate(0.5deg); }
            50% { transform: translate(-50%, -50%) rotate(var(--rot, 0deg)) scale(0.96) rotate(0deg); }
            75% { transform: translate(-50%, -50%) rotate(var(--rot, 0deg)) scale(0.98) rotate(-0.5deg); }
        }

        /* Bubble tails (diamond rotated 45deg) with black border */
        .speech-bubble .tail {
            position: absolute;
            transform: rotate(45deg);
            background: #fff8ea;
        }
        .speech-bubble .tail::before {
            content: "";
            position: absolute;
            inset: 0px;
            background: #ffffff;
            z-index: -1;
        }

        /* Tail hard dropshadow matching accent */
        .speech-bubble .tail::after {
            content: "";
            position: absolute;
            inset: -10px;
            background: var(--accent);
            transform: translate(36px, 36px) scale(1.12);
            z-index: -1;
        }

        /* Quadrant-specific tilt and tail positions */
        .speech-bubble.top-left { --rot: -6deg; }
        .speech-bubble.top-right { --rot: 5deg; }
        .speech-bubble.bottom-left { --rot: 4deg; }
        .speech-bubble.bottom-right { --rot: -4deg; }

        .speech-bubble.top-left .tail { right: -10px; bottom: -10px; }
        .speech-bubble.top-right .tail { left: -10px; bottom: -10px; }
        .speech-bubble.bottom-left .tail { right: -10px; top: -10px; }
        .speech-bubble.bottom-right .tail { left: -10px; top: -10px; }

        @keyframes floaty {
            0%, 100% { translate: 0 0; }
            50% { translate: 0 -8px; }
        }
    </style>

</head>

<body>

    <!-- Global SVG filter: maps luminance to red/black and adds neon glow -->
    <svg width="0" height="0" style="position:fixed; inset:0; pointer-events:none; opacity:0; z-index:-1">
        <defs>
        <filter id="redMapGlow" x="-50%" y="-50%" width="200%" height="200%" color-interpolation-filters="sRGB">
            <!-- Convert to luminance -->
            <feColorMatrix type="matrix" values="
                0.299 0.587 0.114 0 0
                0.299 0.587 0.114 0 0
                0.299 0.587 0.114 0 0
                0     0     0     1 0" result="lum"/>

            <!-- Increase contrast before mapping -->
            <feComponentTransfer in="lum" result="contrast">
                <feFuncR type="linear" slope="2.2" intercept="-0.6"/>
                <feFuncG type="linear" slope="2.2" intercept="-0.6"/>
                <feFuncB type="linear" slope="2.2" intercept="-0.6"/>
            </feComponentTransfer>

            <!-- Map luminance to red/black gradient -->
            <feComponentTransfer in="contrast" result="redmap">
                <feFuncR type="gamma" amplitude="1.5" exponent="0.8" offset="0"/>
                <feFuncG type="discrete" tableValues="0 0"/>
                <feFuncB type="discrete" tableValues="0 0"/>
            </feComponentTransfer>

            <!-- Create glow effect -->
            <feGaussianBlur in="redmap" stdDeviation="3" result="blur1"/>
            <feGaussianBlur in="redmap" stdDeviation="8" result="blur2"/>
            
            <!-- Merge glows and sharp image -->
            <feMerge result="glow">
                <feMergeNode in="blur2"/>
                <feMergeNode in="blur1"/>
                <feMergeNode in="redmap"/>
            </feMerge>

            <!-- Final intensity boost -->
            <feColorMatrix in="glow" type="matrix" values="
                2.0 0   0   0 0
                0   0   0   0 0
                0   0   0   0 0
                0   0   0   1 0"/>
        </filter>
        </defs>
    </svg>



    <!-- Background particles removed -->
    
    <!-- Autoplay prompt overlay -->
    <div id="autoplay-prompt">
        <div class="prompt-content">
            <h2>🎵 Audio Experience</h2>
            <p>This site features ambient music and audio elements.<br>Click below to enable sound and begin your journey.</p>
            <button id="enable-audio">Enable Audio</button>
        </div>
    </div>

    <!-- Wrap all on-screen content for unified mobile-friendly post FX -->
    <div id="app-root">
        <!-- Page title -->
        <div id="page-title">
            <span>d</span><span>u</span><span>m</span><span>p</span><span>r</span><span>a</span><span>d</span><span>i</span><span>o</span>
        </div>

        <!-- Scene root ensures canvas stacking is explicit on mobile -->
        <div id="scene-root"></div>

        <!-- Persona/Katamari inspired UI container -->
        <div id="ui-layer" aria-hidden="true">
            <button class="speech-bubble top-left" data-quadrant="tl"><span class="letters">nothing</span><span class="tail"></span></button>
            <button class="speech-bubble top-right" data-quadrant="tr"><span class="letters">to</span><span class="tail"></span></button>
            <button class="speech-bubble bottom-left" data-quadrant="bl"><span class="letters">see</span><span class="tail"></span></button>
            <button class="speech-bubble bottom-right" data-quadrant="br"><span class="letters">yet</span><span class="tail"></span></button>
        </div>
    </div>

    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.skypack.dev/three@0.128.0/build/three.module.js",
          "three/addons/": "https://cdn.skypack.dev/three@0.128.0/examples/jsm/"
        }
      }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // Mobile detection
        function detectMobile() {
            const userAgent = navigator.userAgent || navigator.vendor || window.opera;
            const isMobileUA = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(userAgent.toLowerCase());
            const isMobileScreen = window.innerWidth <= 768 || window.innerHeight <= 768;
            const isIOS = /iPad|iPhone|iPod/.test(userAgent) && !window.MSStream;
            const isSafari = /^((?!chrome|android).)*safari/i.test(userAgent);
            
            return {
                isMobile: isMobileUA || isMobileScreen,
                isIOS: isIOS,
                isSafari: isSafari,
                isIOSSafari: isIOS && isSafari
            };
        }
        
        const deviceInfo = detectMobile();
        
        // Apply mobile class to body
        if (deviceInfo.isMobile) {
            document.body.classList.add('mobile');
            console.log('Mobile device detected:', deviceInfo);
        }
        
        // Recheck on resize
        window.addEventListener('resize', () => {
            const newCheck = detectMobile();
            if (newCheck.isMobile && !document.body.classList.contains('mobile')) {
                document.body.classList.add('mobile');
            } else if (!newCheck.isMobile && document.body.classList.contains('mobile')) {
                document.body.classList.remove('mobile');
            }
        });

        // Background particles removed

        // Simple Simplex/Perlin Noise Implementation
        var NOISE = NOISE || { };
        NOISE.Perlin = (function() {
            var iOctaves = 1,
                fPersistence = 0.2,
                fResult, fFreq, fPers,
                aOctFreq, // frequency per octave
                aOctPers, // persistance per octave
                fPersMax; // 1 / max persistence

            var octaveFreq = function() {
                var fFreq, fPers;
                aOctFreq = new Array();
                aOctPers = new Array();
                fPersMax = 0;
                for (var i=0; i < iOctaves; i++) {
                    fFreq = Math.pow(2,i);
                    fPers = Math.pow(fPersistence, i);
                    fPersMax += fPers;
                    aOctFreq.push(fFreq);
                    aOctPers.push(fPers);
                }
                fPersMax = 2 / fPersMax;
            }

            var perm = new Uint8Array(512);
            var p = new Uint8Array(256);
            var grad3 = [[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],
                         [1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],
                         [0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]];

            // Return the dot product for 2d perlin noise
            function dot2(g, x, y) {
                return g[0]*x + g[1]*y;
            }

            // Return the dot product for 3d perlin noise
            function dot3(g, x, y, z) {
                return g[0]*x + g[1]*y + g[2]*z;
            }

            // Seeded random number generator
            function seed(x) {
                x = (x<<13) ^ x;
                return ( 1.0 - ( (x * (x * x * 15731 + 789221) + 1376312589) & 0x7fffffff) / 1073741824.0);
            }

            function init() {
                for (var i = 0; i < 256; i++) {
                    p[i] = Math.abs(~~(seed(i) * 256));
                }
                // To remove the need for index wrapping, double the permutation table length
                for (var i=0; i < 512; i++) {
                    perm[i] = p[i & 255];
                }
            }

            /*
            ** 2D Simplex Noise
            */
            function noise2D (x, y, z) {
                // Find unit grid cell containing point
                var X = Math.floor(x) & 255;
                var Y = Math.floor(y) & 255;
                // Get relative xyz coordinates of point within that cell
                x -= Math.floor(x);
                y -= Math.floor(y);

                var fade = function(t) {
                    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
                };

                var lerp = function(a, b, t) {
                    return (1.0-t)*a + t*b;
                }

                var u = fade(x),
                    v = fade(y);

                // Calculate a set of four hashed gradient indices
                var n00 = perm[X + perm[Y ]] % 12;
                var n01 = perm[X + perm[Y+1]] % 12;
                var n10 = perm[X+1 + perm[Y+1]] % 12;
                var n11 = perm[X+1 + perm[Y+1]] % 12;

                // Calculate noise contributions from each of the four corners
                var gi00 = dot2(grad3[n00], x, y );
                var gi01 = dot2(grad3[n01], x, y-1);
                var gi10 = dot2(grad3[n10], x-1, y );
                var gi11 = dot2(grad3[n11], x-1, y-1);

                // Interpolate the results along axises
                return lerp(
                    lerp(gi00, gi10, u),
                    lerp(gi01, gi11, u),
                    v);
            }

            /*
            ** 3D Simplex Noise
            */
            function noise3D (x, y, z) {
                // Find unit grid cell containing point
                var X = Math.floor(x) & 255;
                var Y = Math.floor(y) & 255;
                var Z = Math.floor(z) & 255;
                // Get relative xyz coordinates of point within that cell
                x -= Math.floor(x);
                y -= Math.floor(y);
                z -= Math.floor(z);

                var fade = function(t) {
                    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
                };

                var lerp = function(a, b, t) {
                    return (1.0-t)*a + t*b;
                }

                var u = fade(x),
                    v = fade(y),
                    w = fade(z);

                // Calculate a set of eight hashed gradient indices
                var n000 = perm[X + perm[Y + perm[Z ]]] % 12;
                var n001 = perm[X + perm[Y + perm[Z+1]]] % 12;
                var n010 = perm[X + perm[Y+1+perm[Z ]]] % 12;
                var n011 = perm[X + perm[Y+1+perm[Z+1]]] % 12;
                var n100 = perm[X+1+perm[Y + perm[Z ]]] % 12;
                var n101 = perm[X+1+perm[Y + perm[Z+1]]] % 12;
                var n110 = perm[X+1+perm[Y+1+perm[Z ]]] % 12;
                var n111 = perm[X+1+perm[Y+1+perm[Z+1]]] % 12;

                // Calculate noise contributions from each of the eight corners
                var gi000 = dot3(grad3[n000], x, y, z );
                var gi001 = dot3(grad3[n001], x, y, z-1);
                var gi010 = dot3(grad3[n010], x, y-1, z );
                var gi011 = dot3(grad3[n011], x, y-1, z-1);
                var gi100 = dot3(grad3[n100], x-1, y, z );
                var gi101 = dot3(grad3[n101], x-1, y, z-1);
                var gi110 = dot3(grad3[n110], x-1, y-1, z );
                var gi111 = dot3(grad3[n111], x-1, y-1, z-1);

                // Interpolate the results along axises
                return lerp(
                    lerp(
                        lerp(gi000, gi100, u),
                        lerp(gi001, gi101, u), w),
                    lerp(
                        lerp(gi010, gi110, u),
                        lerp(gi011, gi111, u), w),
                    v);
            }

            function PerlinNoise(){}
            PerlinNoise.prototype = {
                init : init,
                noise : function(x, y, z) {
                    fResult = 0;
                    for (var i=0; i < iOctaves; i++) {
                        fFreq = aOctFreq[i];
                        fPers = aOctPers[i];
                        switch(arguments.length) {
                            case 3 : fResult += fPers * noise3D(fFreq*x, fFreq*y, fFreq*z);
                                     break;
                            case 2 : fResult += fPers * noise2D(fFreq*x, fFreq*y);
                                     break;
                            default : fResult += fPers * noise3D(fFreq*x, fFreq*y, fFreq*z);
                                      break;
                        }
                    }
                    return (fResult * fPersMax + 0.8) * 0.5
                },
                noiseDetail : function(octaves, persistance) {
                    iOctaves = octaves || iOctaves;
                    fPersistence = persistance || fPersistence;
                    octaveFreq();
                }
            }

            return PerlinNoise;
        }).call(this);

        let scene, camera, renderer, controls;
        let planetGroup, moonOrbit;
        let perlin;
        let mouse, raycaster;
        let wasHovered = false;
        let planetMesh, outlineMesh, moonOutlineRef;
        let satelliteOrbit, satelliteGroup, satelliteRoot, satelliteOutlineRef;
        let animating = false;
        let animationStartTime;
        const animationDuration = 0.5; // seconds for one bounce
        let hoverEnabled = false;

        function onMouseMove(event) {
            hoverEnabled = true;
            mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
            mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = null; // Transparent - let the black body background show through unfiltered

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 3; // Zoomed out further for smaller appearance

            // Attach WebGL canvas inside #scene-root for reliable mobile z-ordering
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: 'high-performance' });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 0); // Transparent clear color
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('scene-root').appendChild(renderer.domElement);
            // iOS sometimes blocks pointer events through filtered parents; ensure canvas accepts taps
            renderer.domElement.style.touchAction = 'none';
            renderer.domElement.style.pointerEvents = 'auto';

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.enableZoom = false;
            controls.enablePan = false;

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
            scene.add(ambientLight);

            // Sunlight with shadows
            const sunLight = new THREE.DirectionalLight(0xfff8e7, 1.0);
            sunLight.position.set(10, 10, 54);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 50;
            sunLight.shadow.camera.left = -10;
            sunLight.shadow.camera.right = 10;
            sunLight.shadow.camera.top = 10;
            sunLight.shadow.camera.bottom = -10;
            scene.add(sunLight);

            // Mouse and raycaster setup
            mouse = new THREE.Vector2();
            raycaster = new THREE.Raycaster();
            // Desktop hover
            window.addEventListener( 'mousemove', onMouseMove, false );
            // Mobile touch: map first touch point to mouse for hit testing
            window.addEventListener('touchstart', (e) => {
                if (!e.touches || e.touches.length === 0) return;
                const t = e.touches[0];
                mouse.x = ( t.clientX / window.innerWidth ) * 2 - 1;
                mouse.y = - ( t.clientY / window.innerHeight ) * 2 + 1;
                hoverEnabled = true;
            }, { passive: true });
            window.addEventListener('touchmove', (e) => {
                if (!e.touches || e.touches.length === 0) return;
                const t = e.touches[0];
                mouse.x = ( t.clientX / window.innerWidth ) * 2 - 1;
                mouse.y = - ( t.clientY / window.innerHeight ) * 2 + 1;
            }, { passive: true });

            // Initialize noise
            perlin = new NOISE.Perlin();
            perlin.init();
            perlin.noiseDetail(4, 0.5); // More detailed noise for realistic continents

            // --- Create the Planet ---
            planetGroup = new THREE.Group();
            scene.add(planetGroup);

            const planetRadius = 0.5; // Smaller planet
            const planetGeometry = new THREE.IcosahedronGeometry(planetRadius, 4); // Higher detail for better noise

            // Displace vertices for terrain
            const positionAttribute = planetGeometry.attributes.position;
            for (let i = 0; i < positionAttribute.count; i++) {
                const vertex = new THREE.Vector3().fromBufferAttribute(positionAttribute, i);
                const normalized = vertex.clone().normalize();
                const theta = Math.acos(normalized.y);
                const phi = Math.atan2(normalized.x, normalized.z);
                const noiseValue = perlin.noise(phi * 3, theta * 3); // Adjusted scale for continent size
                let height = 0;
                if (noiseValue > 0.4) { // Higher threshold for more water coverage
                    height = (noiseValue - 0.4) / 0.6 * 0.2; // Bulge up to 20% for cartoony exaggeration
                }
                vertex.multiplyScalar(1 + height);
                positionAttribute.setXYZ(i, vertex.x, vertex.y, vertex.z);
            }
            planetGeometry.computeVertexNormals();

            // Add vertex colors for ocean/land
            const colors = new Float32Array(positionAttribute.count * 3);
            for (let i = 0; i < positionAttribute.count; i++) {
                const vertex = new THREE.Vector3().fromBufferAttribute(positionAttribute, i);
                const len = vertex.length();
                const height = (len - planetRadius) / planetRadius;
                let color;
                if (height > 0) {
                    color = new THREE.Color(0x6a8c45); // Darker green land
                } else {
                    color = new THREE.Color(0x2e5a7a); // Darker blue ocean
                }
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
            }
            planetGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const planetMaterial = new THREE.MeshToonMaterial({ vertexColors: true });
            planetMesh = new THREE.Mesh(planetGeometry, planetMaterial);
            planetMesh.castShadow = true;
            planetMesh.receiveShadow = true;
            planetGroup.add(planetMesh);

            // Planet outline in peach color
            const planetOutlineMaterial = new THREE.MeshBasicMaterial({ color: 0xffdab9, side: THREE.BackSide });
            const outlineGeometry = planetGeometry.clone();
            outlineMesh = new THREE.Mesh(outlineGeometry, planetOutlineMaterial);
            outlineMesh.scale.setScalar(1.05); // Slightly larger for outline
            planetGroup.add(outlineMesh);

            // Clouds for cartoony atmosphere
            const cloudGeometry = new THREE.SphereGeometry(planetRadius * 1.01, 32, 16);
            const cloudPositionAttribute = cloudGeometry.attributes.position;
            for (let i = 0; i < cloudPositionAttribute.count; i++) {
                const vertex = new THREE.Vector3().fromBufferAttribute(cloudPositionAttribute, i);
                const normalized = vertex.clone().normalize();
                const theta = Math.acos(normalized.y);
                const phi = Math.atan2(normalized.x, normalized.z);
                const noiseValue = perlin.noise(phi * 8, theta * 8); // Higher frequency for fluffy clouds
                if (noiseValue > 0.6) {
                    const height = (noiseValue - 0.6) / 0.4 * 0.03; // Small puffs
                    vertex.multiplyScalar(1 + height);
                    cloudPositionAttribute.setXYZ(i, vertex.x, vertex.y, vertex.z);
                }
            }
            cloudGeometry.computeVertexNormals();

            const cloudMaterial = new THREE.MeshLambertMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.3
            });
            const clouds = new THREE.Mesh(cloudGeometry, cloudMaterial);
            clouds.castShadow = true;
            clouds.receiveShadow = true;
            planetGroup.add(clouds);

            // --- Create the Moon ---
            moonOrbit = new THREE.Group();
            scene.add(moonOrbit);

            const moonGroup = new THREE.Group();
            const moonRadius = 0.15; // Smaller moon to match scaled planet
            const moonGeometry = new THREE.IcosahedronGeometry(moonRadius, 2); // Lower poly moon

            const moonMaterial = new THREE.MeshToonMaterial({ color: 0xcccccc });
            const moonMesh = new THREE.Mesh(moonGeometry, moonMaterial);
            moonMesh.castShadow = true;
            moonMesh.receiveShadow = true;
            moonGroup.add(moonMesh);

            // Moon outline in light pastel blue
            const moonOutlineMaterial = new THREE.MeshBasicMaterial({ color: 0xadd8e6, side: THREE.BackSide });
            const moonOutline = new THREE.Mesh(moonGeometry, moonOutlineMaterial);
            moonOutline.scale.setScalar(1.1);
            moonGroup.add(moonOutline);
            moonOutlineRef = moonOutline;

            // Add craters to the moon
            function addCrater(parent, scale, position) {
                const craterGeometry = new THREE.SphereGeometry(moonRadius * scale, 8, 8);
                const craterMesh = new THREE.Mesh(craterGeometry, new THREE.MeshToonMaterial({ color: 0xaaaaaa }));
                craterMesh.position.copy(position).multiplyScalar(moonRadius * 0.9); // Push slightly inwards
                craterMesh.scale.set(1, 1, 0.2); // Flatten the sphere into a dish
                parent.add(craterMesh);

                const craterOutline = new THREE.Mesh(craterGeometry, new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.BackSide }));
                craterOutline.scale.set(1.1, 1.1, 0.25); // Outline for the crater
                craterOutline.position.copy(position).multiplyScalar(moonRadius * 0.9);
                parent.add(craterOutline);
            }

            // Generate some random craters
            for (let i = 0; i < 5; i++) {
                const craterSize = THREE.MathUtils.randFloat(0.15, 0.3);
                // Generate a random direction using spherical coordinates
                const pos = new THREE.Vector3();
                const phi = THREE.MathUtils.randFloat(0, Math.PI * 2); // Random angle around (0 to 360 degrees)
                const theta = Math.acos(THREE.MathUtils.randFloat(-1, 1)); // Random angle from pole (0 to 180 degrees)
                pos.setFromSphericalCoords(1, phi, theta); // Set vector from these angles

                addCrater(moonGroup, craterSize, pos);
            }

            moonGroup.position.x = 1.0; // Smaller orbit for smaller planet
            moonOrbit.add(moonGroup);

            // --- Create the Satellite (opposite side of the moon) ---
            satelliteOrbit = new THREE.Group();
            scene.add(satelliteOrbit);

            satelliteGroup = new THREE.Group();
            satelliteGroup.position.x = -1.0; // opposite the moon along X
            satelliteOrbit.add(satelliteGroup);

            const loader = new GLTFLoader();
            loader.load('./models/satellite.glb', (gltf) => {
                satelliteRoot = gltf.scene;
                // Normalize scale a bit for scene
                const desiredSize = 0.95; // approximate height
                const box = new THREE.Box3().setFromObject(satelliteRoot);
                const size = new THREE.Vector3();
                box.getSize(size);
                const maxDim = Math.max(size.x, size.y, size.z) || 1;
                const scale = desiredSize / maxDim;
                satelliteRoot.scale.setScalar(scale);

                // Enable shadows for satellite
                satelliteRoot.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });

                // Create satellite outline by cloning and scaling the actual satellite geometry
                const satelliteOutlineGeometry = satelliteRoot.clone();
                const outlineMaterials = []; // Store materials for color changes
                satelliteOutlineGeometry.traverse((child) => {
                    if (child.isMesh) {
                        const outlineMaterial = new THREE.MeshBasicMaterial({ color: 0xffdab9, side: THREE.BackSide });
                        child.material = outlineMaterial;
                        outlineMaterials.push(outlineMaterial);
                    }
                });
                satelliteOutlineGeometry.scale.set(0.22, 0.17, 0.19); // Squish in Z axis for flatter outline
                // Apply the same initial rotation as the actual satellite
                satelliteOutlineGeometry.rotation.y = -Math.PI / 2;
                satelliteGroup.add(satelliteOutlineGeometry);
                satelliteOutlineRef = { group: satelliteOutlineGeometry, materials: outlineMaterials };

                // Ensure +X faces away from the planet as it orbits
                // We'll rotate it so its local +X points from planet to satellite
                satelliteRoot.rotation.y = -Math.PI / 2; // align model's +X to point outward when group looks at planet
                satelliteGroup.add(satelliteRoot);
            });

            // Mobile touch and click event handlers - attach after canvas is in DOM
            renderer.domElement.addEventListener('click', onPlanetClick, { passive: true });
            renderer.domElement.addEventListener('touchend', (e) => {
                if (e.changedTouches && e.changedTouches.length === 1) {
                    onPlanetClick(e);
                }
            }, { passive: true });

            window.addEventListener('resize', onWindowResize, false);

            // Apply jitter to page title characters
            const titleChars = document.querySelectorAll('#page-title span');
            titleChars.forEach((char, i) => {
                const jx = (Math.random() * 4 - 1) * 2; // -3..3px
                const jy = (Math.random() * 4 - 1) * 2;
                const jr = (Math.random() * 4 - 1) * 2; // -2..2deg
                char.style.setProperty('--jx', jx + 'px');
                char.style.setProperty('--jy', jy + 'px');
                char.style.setProperty('--jr', jr + 'deg');
                char.style.animationDelay = (i * 0.2) + 's';
            });

            // --- Audio: staged playback ---
            // DON'T add postfx-on at start - we want normal colors first

            const pathLoop = './loop/nighttime_loop.mp3';
            const pathStatic = './loop/static.mp3';
            const baseStreamUrl = 'http://18.119.96.195:8000/radio.mp3';
            
            // Helper function to get fresh stream URL with cache-busting
            const getFreshStreamUrl = () => {
                try {
                    const url = `${baseStreamUrl}?t=${Date.now()}&nocache=${Math.random()}`;
                    console.log('getFreshStreamUrl generated:', url);
                    return url;
                } catch (err) {
                    console.error('Error in getFreshStreamUrl:', err);
                    return baseStreamUrl; // Fallback to base URL
                }
            };

            audioLoop = new Audio(pathLoop);
            audioLoop.loop = true;
            audioLoop.volume = 0.03; // 25%
            audioLoop.crossOrigin = 'anonymous'; // Enable for Web Audio API
            audioLoop.preload = 'auto'; // iOS needs explicit preload

            audioStatic = new Audio(pathStatic);
            audioStatic.loop = false;
            audioStatic.volume = 1.0;
            audioStatic.preload = 'auto';

            audioStream = new Audio();
            
            // iOS Safari audio configuration
            if (deviceInfo.isIOSSafari) {
                console.log('iOS Safari detected - applying audio fixes');
                audioStream.preload = 'metadata'; // iOS prefers metadata over auto for streams
                // Enable playsinline for iOS
                audioStream.setAttribute('playsinline', '');
                audioStream.setAttribute('webkit-playsinline', '');
                audioLoop.setAttribute('playsinline', '');
                audioLoop.setAttribute('webkit-playsinline', '');
                audioStatic.setAttribute('playsinline', '');
                audioStatic.setAttribute('webkit-playsinline', '');
                
                // iOS Safari needs explicit src set early for some MIME detection
                audioStream.src = ''; // Empty src first
                
                // Check MIME type support
                const mp3Support = audioStream.canPlayType('audio/mpeg');
                const mp3Support2 = audioStream.canPlayType('audio/mp3');
                console.log('iOS Safari audio/mpeg support:', mp3Support);
                console.log('iOS Safari audio/mp3 support:', mp3Support2);
                
                // Don't set crossOrigin for iOS Safari - it can cause playback issues
                console.log('iOS Safari: NOT setting crossOrigin to avoid CORS issues');
            } else {
                audioStream.crossOrigin = 'anonymous';
                audioStream.preload = 'none'; // Don't buffer ahead for live streams on other platforms
            }
            
            // Don't set initial URL - will be set when actually needed
            console.log('Audio stream element created, will set URL on first use');
            
            // Stream health monitoring and recovery
            let streamStallTimer = null;
            let lastPlayPosition = 0;
            let streamCheckInterval = null;
            let streamRefreshInterval = null;
            let streamStartTime = Date.now();
            
            // Monitor stream health every 2 seconds
            const monitorStream = () => {
                if (!audioStream || audioStream.paused) return;
                
                const currentTime = audioStream.currentTime;
                
                // If position hasn't changed and we're supposed to be playing, we're stalled
                if (currentTime === lastPlayPosition && !audioStream.paused) {
                    console.warn('Stream stalled, attempting recovery with fresh URL...');
                    audioStream.src = getFreshStreamUrl(); // Get fresh stream URL
                    audioStream.load(); // Reload stream
                    audioStream.play().catch(() => {});
                }
                
                lastPlayPosition = currentTime;
            };
            
            // Refresh stream connection every 5 minutes to ensure we're on the live edge
            const refreshStreamConnection = () => {
                if (!audioStream || audioStream.paused) return;
                
                const elapsed = (Date.now() - streamStartTime) / 1000;
                if (elapsed > 300) { // 5 minutes
                    console.log('Refreshing stream connection to stay on live edge...');
                    const currentVolume = audioStream.volume;
                    audioStream.src = getFreshStreamUrl();
                    audioStream.load();
                    audioStream.volume = currentVolume;
                    audioStream.play().catch(() => {});
                    streamStartTime = Date.now();
                }
            };
            
            // Handle stream errors with detailed iOS Safari logging
            audioStream.addEventListener('error', (e) => {
                console.error('Stream error event:', e);
                if (audioStream.error) {
                    console.error('Stream error code:', audioStream.error.code);
                    console.error('Stream error message:', audioStream.error.message);
                    // Error codes: 1=ABORTED, 2=NETWORK, 3=DECODE, 4=SRC_NOT_SUPPORTED
                    if (audioStream.error.code === 2) {
                        console.error('NETWORK ERROR - Check CORS, connectivity, or server');
                    } else if (audioStream.error.code === 4) {
                        console.error('SRC_NOT_SUPPORTED - Check MIME type or format');
                    }
                }
                
                if (deviceInfo.isIOSSafari) {
                    console.log('iOS Safari: Stream error detected, attempting recovery...');
                }
                
                // Attempt to recover after a short delay with fresh URL
                setTimeout(() => {
                    if (audioStream && !audioStream.paused) {
                        console.log('Recovering stream with fresh URL...');
                        audioStream.src = getFreshStreamUrl();
                        audioStream.load();
                        audioStream.play().catch(() => {});
                    }
                }, 1000);
            });
            
            // Handle stalling/waiting
            audioStream.addEventListener('waiting', () => {
                console.warn('Stream buffering...');
                // If buffering takes too long, reload with fresh URL
                streamStallTimer = setTimeout(() => {
                    console.warn('Buffer stall timeout, reloading stream with fresh URL...');
                    audioStream.src = getFreshStreamUrl();
                    audioStream.load();
                    audioStream.play().catch(() => {});
                }, 5000); // 5 second timeout
            });
            
            audioStream.addEventListener('playing', () => {
                // Clear stall timer when playing resumes
                if (streamStallTimer) {
                    clearTimeout(streamStallTimer);
                    streamStallTimer = null;
                }
                // Start monitoring
                if (!streamCheckInterval) {
                    streamCheckInterval = setInterval(monitorStream, 2000);
                }
                // Start periodic refresh to stay on live edge
                if (!streamRefreshInterval) {
                    streamRefreshInterval = setInterval(refreshStreamConnection, 30000); // Check every 30 seconds
                }
                // Reset stream start time
                streamStartTime = Date.now();
            });
            
            audioStream.addEventListener('pause', () => {
                // Stop monitoring when paused
                if (streamCheckInterval) {
                    clearInterval(streamCheckInterval);
                    streamCheckInterval = null;
                }
                // Stop periodic refresh
                if (streamRefreshInterval) {
                    clearInterval(streamRefreshInterval);
                    streamRefreshInterval = null;
                }
            });
            
            // Log when stream starts loading (helps debug caching issues)
            audioStream.addEventListener('loadstart', () => {
                console.log('Stream loading started:', audioStream.src);
                console.log('Stream connected to analyser:', !!streamSource);
                if (deviceInfo.isIOSSafari) {
                    console.log('iOS Safari: loadstart event fired');
                }
            });
            
            // Log successful metadata load
            audioStream.addEventListener('loadedmetadata', () => {
                console.log('Stream metadata loaded successfully');
                if (deviceInfo.isIOSSafari) {
                    console.log('iOS Safari: Metadata loaded - stream format recognized');
                    console.log('iOS Safari: Duration:', audioStream.duration);
                }
            });
            
            // Track when stream has data available
            audioStream.addEventListener('canplay', () => {
                console.log('Stream can play - data available');
                if (deviceInfo.isIOSSafari) {
                    console.log('iOS Safari: canplay event - ready to play');
                }
            });
            
            // Track when stream actually starts playing
            audioStream.addEventListener('play', () => {
                console.log('Stream play event - stream is playing');
                if (deviceInfo.isIOSSafari) {
                    console.log('iOS Safari: play event fired successfully');
                }
                // Check audio setup after stream starts
                setTimeout(() => {
                    checkAudioSetup();
                }, 1000);
            });
            
            // Additional iOS debugging events
            if (deviceInfo.isIOSSafari) {
                audioStream.addEventListener('loadeddata', () => {
                    console.log('iOS Safari: loadeddata - first frame loaded');
                });
                
                audioStream.addEventListener('canplaythrough', () => {
                    console.log('iOS Safari: canplaythrough - can play without buffering');
                });
                
                audioStream.addEventListener('progress', () => {
                    console.log('iOS Safari: progress - downloading...');
                });
                
                audioStream.addEventListener('suspend', () => {
                    console.log('iOS Safari: suspend - download suspended');
                });
                
                audioStream.addEventListener('stalled', () => {
                    console.log('iOS Safari: stalled - download stalled');
                });
                
                audioStream.addEventListener('abort', () => {
                    console.log('iOS Safari: abort - download aborted');
                });
                
                audioStream.addEventListener('emptied', () => {
                    console.log('iOS Safari: emptied - media element reset');
                });
            }
            
            // Expose debug function to window for manual testing
            window.checkAudioSetup = checkAudioSetup;
            
            // iOS Safari: Comprehensive diagnostic function
            if (deviceInfo.isIOSSafari) {
                window.diagnoseIOSAudio = () => {
                    console.log('=== iOS Safari Audio Diagnostics ===');
                    console.log('Device Info:', deviceInfo);
                    console.log('Audio Stream State:', {
                        src: audioStream.src,
                        paused: audioStream.paused,
                        ended: audioStream.ended,
                        currentTime: audioStream.currentTime,
                        duration: audioStream.duration,
                        volume: audioStream.volume,
                        muted: audioStream.muted,
                        readyState: audioStream.readyState,
                        networkState: audioStream.networkState,
                        error: audioStream.error ? {
                            code: audioStream.error.code,
                            message: audioStream.error.message
                        } : null
                    });
                    console.log('AudioContext:', audioContext ? {
                        state: audioContext.state,
                        sampleRate: audioContext.sampleRate
                    } : 'Not initialized');
                    console.log('Stream Source:', streamSource);
                    console.log('Can Play Types:', {
                        'audio/mpeg': audioStream.canPlayType('audio/mpeg'),
                        'audio/mp3': audioStream.canPlayType('audio/mp3'),
                        'audio/mpeg;codecs=mp3': audioStream.canPlayType('audio/mpeg;codecs=mp3')
                    });
                    console.log('Page Protocol:', window.location.protocol);
                    console.log('Stream URL Protocol:', audioStream.src ? new URL(audioStream.src).protocol : 'none');
                    console.log('=== End Diagnostics ===');
                };
                console.log('iOS Safari: Run window.diagnoseIOSAudio() in console for detailed diagnostics');
            }

            // Try autoplay, show prompt if blocked
            let audioEnabled = false;
            const promptOverlay = document.getElementById('autoplay-prompt');
            const enableBtn = document.getElementById('enable-audio');
            
            const startAudio = () => {
                audioEnabled = true;
                
                // Initialize Web Audio API for visualization (only once)
                if (!audioContext) {
                    try {
                        setupAudioVisualization(audioLoop, 'ambient loop');
                        // Resume audio context if suspended - critical for iOS Safari
                        if (audioContext.state === 'suspended') {
                            audioContext.resume().then(() => {
                                console.log('AudioContext resumed');
                                // iOS Safari: Ensure all audio elements are ready after resume
                                if (deviceInfo.isIOSSafari) {
                                    console.log('iOS Safari: AudioContext resumed after user interaction');
                                }
                            });
                        }
                    } catch (err) {
                        console.warn('Could not setup audio visualization:', err);
                    }
                }
                
                // iOS Safari: Explicit play attempt for all audio elements after user gesture
                if (deviceInfo.isIOSSafari) {
                    // Touch all audio elements to initialize them with user gesture
                    [audioLoop, audioStatic, audioStream].forEach(audio => {
                        if (audio) {
                            audio.load(); // Reload to ensure iOS recognizes user gesture
                        }
                    });
                }
                
                // PRELOAD STREAM EARLY - connect and start buffering at 0 volume
                // Skip for iOS Safari - let user explicitly start the stream
                if (!streamSource && audioContext && !deviceInfo.isIOSSafari) {
                    try {
                        console.log('Early stream preload: Connecting stream to analyser...');
                        streamSource = setupAudioVisualization(audioStream, 'radio stream');
                        
                        // Set URL and start loading immediately
                        const timestamp = Date.now();
                        const random = Math.random();
                        audioStream.src = `http://18.119.96.195:8000/radio.mp3?t=${timestamp}&nocache=${random}`;
                        console.log('Early stream preload: URL set, loading stream...');
                        audioStream.load();
                        
                        // Start playing silently in background to buffer
                        audioStream.volume = 0;
                        audioStream.play().then(() => {
                            console.log('Stream preloaded and buffering in background at 0 volume');
                        }).catch(err => {
                            console.warn('Early stream preload play failed:', err);
                        });
                    } catch (err) {
                        console.error('Early stream preload failed:', err);
                    }
                } else if (deviceInfo.isIOSSafari) {
                    console.log('iOS Safari: Skipping early stream preload, waiting for user play button');
                }
                
                audioLoop.play().catch(() => {});
                // Hide prompt with fade out
                promptOverlay?.classList.remove('show');
            };
            
            // Try silent autoplay test
            audioLoop.play().then(() => {
                // Autoplay succeeded! Audio is enabled
                audioEnabled = true;
                console.log('Autoplay allowed by browser');
                
                // Initialize Web Audio API for visualization
                if (!audioContext) {
                    try {
                        setupAudioVisualization(audioLoop, 'ambient loop');
                        // Resume audio context if suspended
                        if (audioContext && audioContext.state === 'suspended') {
                            audioContext.resume().then(() => {
                                console.log('AudioContext resumed after autoplay');
                            });
                        }
                    } catch (err) {
                        console.warn('Could not setup audio visualization:', err);
                    }
                }
                
                // PRELOAD STREAM EARLY on autoplay success too
                // Skip for iOS Safari - let user explicitly start the stream
                if (!streamSource && audioContext && !deviceInfo.isIOSSafari) {
                    try {
                        console.log('Early stream preload (autoplay): Connecting stream to analyser...');
                        streamSource = setupAudioVisualization(audioStream, 'radio stream');
                        
                        // Set URL and start loading immediately
                        const timestamp = Date.now();
                        const random = Math.random();
                        audioStream.src = `http://18.119.96.195:8000/radio.mp3?t=${timestamp}&nocache=${random}`;
                        console.log('Early stream preload (autoplay): URL set, loading stream...');
                        audioStream.load();
                        
                        // Start playing silently in background to buffer
                        audioStream.volume = 0;
                        audioStream.play().then(() => {
                            console.log('Stream preloaded and buffering in background at 0 volume (autoplay path)');
                        }).catch(err => {
                            console.warn('Early stream preload play failed (autoplay):', err);
                        });
                    } catch (err) {
                        console.error('Early stream preload failed (autoplay):', err);
                    }
                } else if (deviceInfo.isIOSSafari) {
                    console.log('iOS Safari (autoplay): Skipping early stream preload, waiting for user play button');
                }
            }).catch(() => {
                // Autoplay blocked - show our custom prompt
                console.log('Autoplay blocked, showing prompt');
                promptOverlay?.classList.add('show');
            });
            
            // Handle enable audio button
            enableBtn?.addEventListener('click', () => {
                startAudio();
            });

            // Controls
            const btnPlay = document.getElementById('btn-play');
            const btnPause = document.getElementById('btn-pause');
            const btnDiscord = document.getElementById('btn-discord');
            const volSlider = document.getElementById('volume-slider');

            const setRadioVolumeFromSlider = () => {
                const v = Number(volSlider?.value ?? 35); // default 35
                const scaled = Math.min(1, Math.max(0, (v / 100) * radioScale));
                audioStream.volume = scaled;
            };
            setRadioVolumeFromSlider();

            btnPlay?.addEventListener('click', (e) => {
                e.stopPropagation();
                
                console.log('Play button clicked');
                
                // Ensure audio context is running - critical for iOS Safari
                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume().then(() => {
                        console.log('AudioContext resumed on play button');
                    });
                }
                
                // If stream hasn't been connected yet, connect it first
                // Skip Web Audio API for iOS Safari to avoid CORS issues
                if (audioContext && !streamSource && !deviceInfo.isIOSSafari) {
                    try {
                        console.log('First play - connecting stream to analyser...');
                        streamSource = setupAudioVisualization(audioStream, 'radio stream');
                        console.log('Stream connected successfully');
                    } catch (err) {
                        console.error('Failed to connect stream:', err);
                    }
                } else if (deviceInfo.isIOSSafari && !streamSource) {
                    console.log('iOS Safari: Skipping Web Audio API connection, playing stream directly');
                    streamSource = 'skipped'; // Mark as handled to prevent retries
                }
                
                // Get fresh stream URL before playing to ensure live stream
                if (audioStream.paused || !audioStream.src || audioStream.src === window.location.href) {
                    console.log('Play button: Getting fresh stream URL');
                    audioStream.src = getFreshStreamUrl();
                    console.log('New stream URL:', audioStream.src);
                    
                    // iOS Safari: Explicit MIME type and load
                    if (deviceInfo.isIOSSafari) {
                        console.log('iOS Safari: Setting up stream with explicit MIME type');
                        // Create a new Audio element if needed for iOS Safari
                        const canPlayMp3 = audioStream.canPlayType('audio/mpeg');
                        console.log('iOS Safari can play audio/mpeg:', canPlayMp3);
                    }
                    
                    audioStream.load();
                }
                
                // iOS Safari: Set volume before playing to ensure audio pipeline is ready
                if (deviceInfo.isIOSSafari) {
                    const currentVolume = audioStream.volume;
                    audioStream.volume = currentVolume; // Re-set to ensure iOS registers it
                }
                
                audioStream.play().then(() => {
                    console.log('Stream playing successfully');
                }).catch((err) => {
                    console.error('Play failed:', err);
                    // iOS Safari: Try alternative approach
                    if (deviceInfo.isIOSSafari) {
                        console.log('iOS Safari: Retrying playback after error...');
                        setTimeout(() => {
                            audioStream.load();
                            audioStream.play().catch(e => console.error('iOS Safari retry failed:', e));
                        }, 500);
                    }
                });
            });
            btnPause?.addEventListener('click', (e) => {
                e.stopPropagation();
                audioStream.pause();
            });
            volSlider?.addEventListener('input', (e) => {
                e.stopPropagation();
                setRadioVolumeFromSlider();
            });
            btnDiscord?.addEventListener('click', (e) => {
                e.stopPropagation();
                window.open('https://discord.com/invite/your-server', '_blank', 'noopener');
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function screenPositionOfObject(obj, camera) {
            const vector = new THREE.Vector3();
            obj.getWorldPosition(vector);
            vector.project(camera);
            const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
            return { x, y, behind: vector.z > 1 };
        }

        let uiVisible = false;
        function onPlanetClick(event) {
            // Basic raycast to ensure planet was clicked
            let cx, cy;
            // For touch events, use changedTouches instead of touches for touchend
            if (event.changedTouches && event.changedTouches.length) {
                cx = event.changedTouches[0].clientX;
                cy = event.changedTouches[0].clientY;
            } else if (event.touches && event.touches.length) {
                cx = event.touches[0].clientX;
                cy = event.touches[0].clientY;
            } else {
                cx = event.clientX;
                cy = event.clientY;
            }
            const mouseNDC = new THREE.Vector2(
                ( cx / window.innerWidth ) * 2 - 1,
                - ( cy / window.innerHeight ) * 2 + 1
            );
            raycaster.setFromCamera(mouseNDC, camera);
            const hit = raycaster.intersectObject(planetMesh);
            if (!hit.length) return;

            uiVisible = !uiVisible;
            const ui = document.getElementById('ui-layer');
            ui.setAttribute('aria-hidden', String(!uiVisible));
            ui.classList.toggle('show', uiVisible);
            const accent = uiVisible ? 0xff4d2e : 0xffdab9;
            outlineMesh.material.color.setHex(accent); // planet
            if (moonOutlineRef) moonOutlineRef.material.color.setHex(accent); // moon

            // prepare letter jitter spans once when showing
            if (uiVisible) {
                const labels = document.querySelectorAll('#ui-layer .letters');
                labels.forEach(label => {
                    // If already processed, skip
                    if (label.dataset.split === '1') return;

                    const text = label.textContent || '';
                    label.textContent = '';
                    [...text].forEach((ch, i) => {
                        const span = document.createElement('span');
                        span.textContent = ch;
                        // random small offsets/rotation and stagger
                        const jx = (Math.random() * 2- 1) * 1; // -1.5..1.5px
                        const jy = (Math.random() * 2 - 1) * 1;
                        const jr = (Math.random() * 2 - 1) * 2;   // -2..2deg
                        span.style.setProperty('--jx', jx + 'px');
                        span.style.setProperty('--jy', jy + 'px');
                        span.style.setProperty('--jr', jr + 'deg');
                        span.style.animationDelay = (i * 0.03) + 's';
                        label.appendChild(span);
                    });
                    label.dataset.split = '1';
                });
            }
        }


        function layoutBubbles() {
            if (!uiVisible) return;
            const ui = document.getElementById('ui-layer');
            const tl = ui.querySelector('.top-left');
            const tr = ui.querySelector('.top-right');
            const bl = ui.querySelector('.bottom-left');
            const br = ui.querySelector('.bottom-right');

            // Planet screen position
            const planetScreen = screenPositionOfObject(planetGroup, camera);

            const gap = Math.min(window.innerWidth, window.innerHeight) * (window.innerWidth < 540 ? 0.28 : 0.19); // further on phones

            // Position around planet
            tl.style.left = (planetScreen.x - gap) + 'px';
            tl.style.top  = (planetScreen.y - gap) + 'px';

            tr.style.left = (planetScreen.x + gap) + 'px';
            tr.style.top  = (planetScreen.y - gap) + 'px';

            bl.style.left = (planetScreen.x - gap) + 'px';
            bl.style.top  = (planetScreen.y + gap) + 'px';

            br.style.left = (planetScreen.x + gap) + 'px';
            br.style.top  = (planetScreen.y + gap) + 'px';
        }

        function animate() {
            requestAnimationFrame(animate);

            // Raycast for hover detection only if mouse has moved
            let currentHovered = false;
            if (hoverEnabled) {
                raycaster.setFromCamera( mouse, camera );
                const intersects = raycaster.intersectObject( planetMesh );
                currentHovered = intersects.length > 0;
            }

            // Outline color: when UI is visible, force accent; otherwise use hover feedback
            const outlineColor = uiVisible ? 0xff5f02 : (currentHovered ? 0x333333 : 0xffdab9);
            outlineMesh.material.color.setHex(outlineColor);
            if (moonOutlineRef) moonOutlineRef.material.color.setHex(outlineColor);
            if (satelliteOutlineRef && satelliteOutlineRef.materials) {
                satelliteOutlineRef.materials.forEach(material => material.color.setHex(outlineColor));
            }

            // Bounce animation: trigger once on hover enter (state change)
            if (currentHovered && !wasHovered && !animating) {
                animating = true;
                animationStartTime = performance.now() * 0.001;
            }

            if (animating) {
                const elapsed = performance.now() * 0.001 - animationStartTime;
                if (elapsed < animationDuration) {
                    const progress = elapsed / animationDuration;
                    const bounceScale = 1 + 0.05 * Math.sin( Math.PI * progress ); // One full grow-shrink cycle
                    planetGroup.scale.set( bounceScale, bounceScale, bounceScale );
                } else {
                    animating = false;
                    planetGroup.scale.set( 1, 1, 1 );
                }
            }

            // Reset scale if not hovered and not animating
            if (!currentHovered && !animating) {
                planetGroup.scale.set( 1, 1, 1 );
            }

            // Update previous state
            wasHovered = currentHovered;

            planetGroup.rotation.y += 0.005; // Slightly faster spin
            planetGroup.rotation.x += 0.0008;

            moonOrbit.rotation.y += 0.015; // Faster moon orbit
            moonOrbit.children[0].rotation.y += 0.008; // Faster moon spin

            // Satellite orbit (same speed magnitude, opposite direction)
            if (satelliteOrbit) {
                satelliteOrbit.rotation.y += 0.015;
                if (satelliteGroup) {
                    // keep satellite oriented so its +X points away from planet
                    // by making the group's forward look at the planet, then rotate child so +X faces out
                    satelliteGroup.lookAt(planetGroup.position);
                    if (satelliteRoot) {
                        satelliteRoot.rotation.y = -Math.PI / 2; // maintain outward +X relative to group's lookAt
                    }
                }
            }

            layoutBubbles();
            controls.update();
            renderer.render(scene, camera);
        }

        init();
        animate();
    </script>

</body>

</html>
